/************************************************
 * TeamTalk - 服务端源码阅读.
 * vim 配置文件: .vimrc
 * vim 折叠信息: .vim/view/~=+201903TeamTalk.txt=
 *
 * TODO:
 * 0.MySql Table
 * 1.db_proxy_server
 *   |- async.h
 *   |- DBPool.h
 *   |- DBPool.cpp
 *   |- CachePool.h
 *   |- CachePool.cpp
 *   |- AutoPool.h
 *   |- AutoPool.cpp
 *   |- HandlerMap.h
 *   |- HandlerMap.cpp
 *   |- ProxyTask.h
 *   |- ProxyTask.cpp
 *   |- ProxyConn.h
 *   |- ProxyConn.cpp
 *   |- SyncCenter.h
 *   |- SyncCenter.cpp
 *   |- db_proxy_server.cpp
 *   |- business(业务逻辑)
 *      |- Login.h
 *      |- Login.cpp
 *      |- LoginStrategy.h
 *      |- InterLogin.h
 *      |- InterLogin.cpp
 *      |- ExterLogin.h
 *      |- ExterLogin.cpp
 *      |- AudioModel.h
 *      |- AudioModel.cpp
 *      |- UserModel.h
 *      |- UserModel.cpp
 *      |- UserAction.h
 *      |- UserAction.cpp
 *      |- GroupModel.h
 *      |- GroupModel.cpp
 *      |- GroupAction.h
 *      |- GroupAction.cpp
 *      |- SessionModel.h
 *      |- SessionModel.cpp
 *      |- RecentSession.h
 *      |- RecentSession.cpp
 *      |- RelationModel.h
 *      |- RelationModel.cpp
 *      |- MessageModel.h
 *      |- MessageModel.cpp
 *      |- GroupMessageModel.h
 *      |- GroupMessageModel.cpp
 *      |- MessageCounter.h
 *      |- MessageCounter.cpp
 *      |- MessageContent.h
 *      |- MessageContent.cpp
 *      |- DepartModel.h
 *      |- DepartModel.cpp
 *      |- DepartAction.h
 *      |- DepartAction.cpp
 *      |- FileModel.h
 *      |- FileModel.cpp
 *      |- FileAction.h
 *      |- FileAction.cpp
 *
************************************************/

/* db_proxy_server - 数据库代理服务器,提供mysql以及redis的访问服务.
 * msg_server - 消息服务器,提供客户端大部分信令处理功能,包括私人聊天 群组聊天等.
 * login_server - 负载均衡服务器,分配一个负载小的MsgServer给客户端使用.
 * msfs_server -  图片存储服务器,提供头像,图片传输中的图片存储服务.
 * file_server - 文件服务器,提供客户端之间得文件传输服务,支持在线以及离线文件传输.
 * route_server -路由服务器,为登录在不同MsgServer的用户提供消息转发功能.
 * http_msg_server - 对外接口服务器,提供对外接口功能.
 * push_server - 消息推送服务器,提供IOS系统消息推送.
 */

/* TeamTalk - MySql Table */
--后台管理员表
--password    密码,规则md5(md5(passwd)+salt)
CREATE TABLE `IMAdmin` (
    `id` mediumint(6) unsigned NOT NULL AUTO_INCREMENT,
    `uname` varchar(40) NOT NULL COMMENT '用户名',
    `pwd` char(32) NOT NULL COMMENT '经过md5加密的密码',
    `status` tinyint(2) unsigned NOT NULL DEFAULT '0' COMMENT '用户状态 0 :正常 1:删除 可扩展',
    `created` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间',
    `updated` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间',
    PRIMARY KEY (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8

--存储语音地址
CREATE TABLE `IMAudio` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `fromId` int(11) unsigned NOT NULL COMMENT '发送者Id',
    `toId` int(11) unsigned NOT NULL COMMENT '接收者Id',
    `path` varchar(255) COLLATE utf8mb4_bin DEFAULT '' COMMENT '语音存储的地址',
    `size` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '文件大小',
    `duration` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '语音时长',
    `created` int(11) unsigned NOT NULL COMMENT '创建时间',
    PRIMARY KEY (`id`),
    KEY `idx_fromId_toId` (`fromId`,`toId`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin

--存储部门信息
CREATE TABLE `IMDepart` (
    `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '部门id',
    `departName` varchar(64) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '部门名称',
    `priority` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '显示优先级,相同优先级按拼音顺序排列',
    `parentId` int(11) unsigned NOT NULL COMMENT '上级部门id',
    `status` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '状态',
    `created` int(11) unsigned NOT NULL COMMENT '创建时间',
    `updated` int(11) unsigned NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`),
    KEY `idx_departName` (`departName`),
    KEY `idx_priority_status` (`priority`,`status`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin

--发现配置表
CREATE TABLE `IMDiscovery` (
    `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT 'id',
    `itemName` varchar(64) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '名称',
    `itemUrl` varchar(64) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT 'URL',
    `itemPriority` int(11) unsigned NOT NULL COMMENT '显示优先级',
    `status` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '状态',
    `created` int(11) unsigned NOT NULL COMMENT '创建时间',
    `updated` int(11) unsigned NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`),
    KEY `idx_itemName` (`itemName`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin

--群组表
CREATE TABLE `IMGroup` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `name` varchar(256) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '群名称',
    `avatar` varchar(256) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '群头像',
    `creator` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建者用户id',
    `type` tinyint(3) unsigned NOT NULL DEFAULT '1' COMMENT '群组类型，1-固定;2-临时群',
    `userCnt` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '成员人数',
    `status` tinyint(3) unsigned NOT NULL DEFAULT '1' COMMENT '是否删除,0-正常，1-删除',
    `version` int(11) unsigned NOT NULL DEFAULT '1' COMMENT '群版本号',
    `lastChated` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '最后聊天时间',
    `created` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间',
    `updated` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间',
    PRIMARY KEY (`id`),
    KEY `idx_name` (`name`(191)),
    KEY `idx_creator` (`creator`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT='IM群信息'

--群成员表
CREATE TABLE `IMGroupMember` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `groupId` int(11) unsigned NOT NULL COMMENT '群Id',
    `userId` int(11) unsigned NOT NULL COMMENT '用户id',
    `status` tinyint(4) unsigned NOT NULL DEFAULT '1' COMMENT '是否退出群，0-正常，1-已退出',
    `created` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间',
    `updated` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间',
    PRIMARY KEY (`id`),
    KEY `idx_groupId_userId_status` (`groupId`,`userId`,`status`),
    KEY `idx_userId_status_updated` (`userId`,`status`,`updated`),
    KEY `idx_groupId_updated` (`groupId`,`updated`)
    ) ENGINE=InnoDB AUTO_INCREMENT=68 DEFAULT CHARSET=utf8 COMMENT='用户和群的关系表'

--群消息表,x代表第几张表，目前做了分表有8张:0-7.消息具体在哪张表中，是groupId%IMGroupMessage表的数目
CREATE TABLE `IMGroupMessage_(x)` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `groupId` int(11) unsigned NOT NULL COMMENT '用户的关系id',
    `userId` int(11) unsigned NOT NULL COMMENT '发送用户的id',
    `msgId` int(11) unsigned NOT NULL COMMENT '消息ID',
    `content` varchar(4096) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '消息内容',
    `type` tinyint(3) unsigned NOT NULL DEFAULT '2' COMMENT '群消息类型,101为群语音,2为文本',
    `status` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '消息状态',
    `created` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间',
    `updated` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间',
    PRIMARY KEY (`id`),
    KEY `idx_groupId_status_created` (`groupId`,`status`,`created`),
    KEY `idx_groupId_msgId_status_created` (`groupId`,`msgId`,`status`,`created`)   
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT='IM群消息表'

--消息表，x代表第几张表，目前做了分表有8张:0-7.具体在那张表，是relateId%IMMessage表数目.
CREATE TABLE `IMMessage_0` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `relateId` int(11) unsigned NOT NULL COMMENT '用户的关系id',
    `fromId` int(11) unsigned NOT NULL COMMENT '发送用户的id',
    `toId` int(11) unsigned NOT NULL COMMENT '接收用户的id',
    `msgId` int(11) unsigned NOT NULL COMMENT '消息ID',
    `content` varchar(4096) COLLATE utf8mb4_bin DEFAULT '' COMMENT '消息内容',
    `type` tinyint(2) unsigned NOT NULL DEFAULT '1' COMMENT '消息类型',
    `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '0正常 1被删除',
    `created` int(11) unsigned NOT NULL COMMENT '创建时间', 
    `updated` int(11) unsigned NOT NULL COMMENT '更新时间',     PRIMARY KEY (`id`),
    KEY `idx_relateId_status_created` (`relateId`,`status`,`created`),
    KEY `idx_relateId_status_msgId_created` (`relateId`,`status`,`msgId`,`created`),
    KEY `idx_fromId_toId_created` (`fromId`,`toId`,`status`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin

--最近联系人(会话)表。
CREATE TABLE `IMRecentSession` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `userId` int(11) unsigned NOT NULL COMMENT '用户id',
    `peerId` int(11) unsigned NOT NULL COMMENT '对方id',
    `type` tinyint(1) unsigned DEFAULT '0' COMMENT '类型，1-用户,2-群组',
    `status` tinyint(1) unsigned DEFAULT '0' COMMENT '用户:0-正常, 1-用户A删除,群组:0-正常, 1-被删除',
    `created` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间',
    `updated` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间',
    PRIMARY KEY (`id`),
    KEY `idx_userId_peerId_status_updated` (`userId`,`peerId`,`status`,`updated`),
    KEY `idx_userId_peerId_type` (`userId`,`peerId`,`type`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8

--用户关系表，标识两个用户之间的唯一关系id，用于消息分表。relationId % 消息表数目。
CREATE TABLE `IMRelationShip` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `smallId` int(11) unsigned NOT NULL COMMENT '用户A的id',
    `bigId` int(11) unsigned NOT NULL COMMENT '用户B的id',
    `status` tinyint(1) unsigned DEFAULT '0' COMMENT '用户:0-正常, 1-用户A删除,群组:0-正常, 1-被删除',
    `created` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间',
    `updated` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间',
    PRIMARY KEY (`id`),
    KEY `idx_smallId_bigId_status_updated` (`smallId`,`bigId`,`status`,`updated`)   
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8

--用户表
--password    密码,规则md5(md5(passwd)+salt)
CREATE TABLE `IMUser` (
    `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '用户id',
    `sex` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '1男2女0未知',
    `name` varchar(32) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '用户名',
    `domain` varchar(32) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '拼音',
    `nick` varchar(32) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '花名,绰号等',
    `password` varchar(32) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '密码',
    `salt` varchar(4) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '混淆码',
    `phone` varchar(11) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '手机号码',
    `email` varchar(64) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT 'email',
    `avatar` varchar(255) COLLATE utf8mb4_bin DEFAULT '' COMMENT '自定义用户头像',
    `departId` int(11) unsigned NOT NULL COMMENT '所属部门Id',
    `status` tinyint(2) unsigned DEFAULT '0' COMMENT '1. 试用期 2. 正式 3. 离职 4.实习',
    `sign_info` varchar(32) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '个性签名',
    `created` int(11) unsigned NOT NULL COMMENT '创建时间',
    `updated` int(11) unsigned NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`),
    KEY `idx_domain` (`domain`),
    KEY `idx_name` (`name`),
    KEY `idx_phone` (`phone`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin

--离线文件传输表(同事建议的，待考证)
CREATE TABLE `IMTransmitFile` (  
    `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT 'id',  
    `fromId` int(11) unsigned NOT NULL COMMENT '发送用户的id', 
    `toId` int(11) unsigned NOT NULL COMMENT '接收用户的id',    
    `fileName` varchar(32) COLLATE utf8mb4_bin DEFAULT '' COMMENT '文件名字',  
    `size` int(11) unsigned NOT NULL COMMENT '文件大小',  
    `taskId` varchar(256) COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '任务id',  
    `status` tinyint(1) unsigned DEFAULT '0' COMMENT '状态',   
    `created` int(11) unsigned NOT NULL COMMENT '创建时间',  
    `updated` int(11) unsigned NOT NULL COMMENT '更新时间',  
    PRIMARY KEY (`id`),  
    KEY `idx_taskId` (`taskId`)  
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin; 

/* db_proxy_server - async.h */
#ifndef __HIREDIS_ASYNC_H
#define __HIREDIS_ASYNC_H
#include "hiredis.h"

#ifdef __cplusplus
extern "C" {
#endif

/* redis客户端-Hiredis异步API接口.
 * redisAsyncContext 前置声明, 该异步数据结构在下文中有定义.
 * dict 是Redis字典数据结构.
 */
struct redisAsyncContext; /* need forward declaration of redisAsyncContext */
struct dict; /* dictionary header is included in async.c */

/* Reply callback prototype and container */
/* redisCallbackFn是回调函数原型 */
typedef void (redisCallbackFn)(struct redisAsyncContext*, void*, void*);

/* redisCallback是redisCallbackList -  Redis回调函数链表的结点 */
typedef struct redisCallback {
  struct redisCallback *next; /* simple singly linked list */
  redisCallbackFn *fn;
  void *privdata;
} redisCallback;

/* List of callbacks for either regular replies or pub/sub */
/* redisCallbackList是回调函数链表 */
typedef struct redisCallbackList {
  redisCallback *head, *tail;
} redisCallbackList;

/* Connection callback prototypes */
/* redis连接回调和断开连接回调函数原型 */
typedef void (redisDisconnectCallback)(const struct redisAsyncContext*, int status);
typedef void (redisConnectCallback)(const struct redisAsyncContext*, int status);

/* Context for an async connection to Redis */
/* 异步连接Redis的 "Redis连接信息" 结构体 */
typedef struct redisAsyncContext {
  /* Hold the regular context, so it can be realloc'ed. */
  /* c 是Redis连接套接字 */
  redisContext c;

  /* Setup error flags so they can be used directly. */
  int err;
  char *errstr;

  /* Not used by hiredis */
  void *data;

  /* Event library data and hooks */
  /* 事件数据和钩子函数 */
  /* 插入删除读写事件 和 cleanup清理事件*/
  struct {
    void *data;

    /* Hooks that are called when the library expects to start
     * reading/writing. These functions should be idempotent.
     */
    void (*addRead)(void *privdata);
    void (*delRead)(void *privdata);
    void (*addWrite)(void *privdata);
    void (*delWrite)(void *privdata);
    void (*cleanup)(void *privdata);
  } ev;

  /* Called when either the connection is terminated due to an error or per
   * user request. The status is set accordingly (REDIS_OK, REDIS_ERR). */
  /* Redis断开连接回调函数指针 */
  redisDisconnectCallback *onDisconnect;

  /* Called when the first write event was received. */
  /* Redis建立连接回调函数指针 */
  redisConnectCallback *onConnect;

  /* Regular command callbacks */
  /* Redis 回调函数链表 */
  redisCallbackList replies;

  /* Subscription callbacks */
  /* 消息订阅 */
  struct {
    redisCallbackList invalid;
    struct dict *channels;
    struct dict *patterns;
  } sub;
} redisAsyncContext;

/* Functions that proxy to hiredis.
 * hiredis客户端API接口.
 * redisAsyncConnect 连接Redis.
 * redisAsyncConnectBind 绑定地址-连接Redis.
 * redisAsyncConnectBindWithReuse 绑定地址并端口复用-连接Redis.
 * redisAsyncConnectUnix 连接Unix.
 * redisAsyncSetConnectCallback 设置Redis建立连接回调函数.
 * redisAsyncSetDisconnectCallback 设置Redis断开连接回调函数.
 * redisAsyncDisconnect 断开连接.
 * redisAsyncFree 释放内存
 */
redisAsyncContext *redisAsyncConnect(const char *ip, int port);
redisAsyncContext *redisAsyncConnectBind(const char *ip, int port, const char *source_addr);
redisAsyncContext *redisAsyncConnectBindWithReuse(const char *ip, int port, const char *source_addr);
redisAsyncContext *redisAsyncConnectUnix(const char *path);
int redisAsyncSetConnectCallback(redisAsyncContext *ac, redisConnectCallback *fn);
int redisAsyncSetDisconnectCallback(redisAsyncContext *ac, redisDisconnectCallback *fn);
void redisAsyncDisconnect(redisAsyncContext *ac);
void redisAsyncFree(redisAsyncContext *ac);

/* Handle read/write events */
/* hiredis客户端执行读写事件 */
void redisAsyncHandleRead(redisAsyncContext *ac);
void redisAsyncHandleWrite(redisAsyncContext *ac);

/* Command functions for an async context. Write the command to the
 * output buffer and register the provided callback. */
/* hiredis客户端写入命令注册回调函数 */
int redisvAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, va_list ap);
int redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, ...);
int redisAsyncCommandArgv(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, int argc, const char **argv, const size_t *argvlen);
int redisAsyncFormattedCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *cmd, size_t len);

#ifdef __cplusplus
}
#endif

#endif

/* db_proxy_server - DBPool.h */
#ifndef DBPOOL_H_
#define DBPOOL_H_

#include "../base/util.h"
#include "ThreadPool.h"
#include <mysql.h>

#define MAX_ESCAPE_STRING_LEN	10240

/* MySql数据结构
 * MYSQL - This structure represents handler for one database connection.
 * MYSQL 是数据库连接的句柄,类似于套接字socket.
 * MYSQL_RES - This structure represents the result of a query that returns rows (SELECT, SHOW, DESCRIBE, EXPLAIN).
 * MYSQL_RES 是用于做为资源的结构体.
 * MYSQL_ROW - This is a type-safe representation of one row of data.
 * MYSQL_ROW 是MYSQL自带的结构类型(定义域mysql.h中的字符串数组,typedef char **MYSQL_ROW;).
 * MYSQL_FIELD - This structure contains metadata: information about a field, such as the field's name, type, and size.
 * MYSQL_FIELD 是表字段. 
 * MYSQL_STMT - This structure is a handler for a prepared statement.
 * MYSQL_STMT 是预处理程序的句柄, mysql_stmt_init()返回的一个MYSQL_STMT指针.
 * MYSQL_BIND - This structure is used both for statement input and output.
 * MYSQL_BIND 提供预处理程序的输入输出参数.
 * --作为输入参数使用时,先使用mysql_stmt_bind_param()绑定参数,之后再执行mysql_stmt_execute().
 * --作为输出参数使用时,需要mysql_stmt_bind_result()将结果绑定到缓存,用 mysql_stmt_fetch()获取一行结果.
 *
 * 23.8.8 C API Prepared Statements(预处理语句)
 * MySQL可以使用预处理语句.通过使用 mysql_stmt_init() 初始化方法返回一个MYSQL_STMT*句柄.
 * Prepared Statements对一条语句执行多次效率很高,因为语句只有第一次执行时被解析,之后
 * 再次执行都是使用已经初始化的MYSQL_STMT*句柄.
 *
 * 23.8.9 C API Prepared Statement Data Structures(预处理语句数据结构).
 * 传参MYSQL连接句柄给mysql_stmt_init(MYSQL *mysql),返回一个MYSQL_STMT数据结构指针.
 * 将MYSQL_STMT指针和指定预处理的sql语句传给mysql_stmt_prepare(),后者将返回一个状态值.
 * 预处理的sql语句结尾不需要";"分号.且sql语句传参使用"?"做参数标志符号.例如:
 * "INSERT INTO test_table(col1,col2,col3) VALUES(?,?,?)"
 * "SELECT col1,col2,col3,col4 FROM test_table"
 * 所以执行sql语句之前,需要使用mysql_stmt_bind_param()对"?"标识符根据其参数类型绑定实际参数.
 * 为了提供输入参数,需要设置MYSQL_BIND数据结构并且传参至mysql_stmt_bind_param().
 * 同理为了获取返回结果, 需要设置MYSQL_BIND数据结构并且传参至mysql_stmt_bind_result().
 */
 
/* CResultSet - MYSQL资源对象,保存MYSQL查询语句的执行结果集 */
class CResultSet {
public:
  CResultSet(MYSQL_RES* res);
  virtual ~CResultSet();

  bool Next();
  int GetInt(const char* key);
  char* GetString(const char* key);
private:
  int _GetIndex(const char* key);

  MYSQL_RES*  m_res;
  MYSQL_ROW   m_row;
  map<string, int> m_key_map;
};

/* CPrepareStatement - SQL语句预处理对象 */
class CPrepareStatement {
public:
  CPrepareStatement();
  virtual ~CPrepareStatement();

  bool Init(MYSQL* mysql, string& sql);

  void SetParam(uint32_t index, int& value);
  void SetParam(uint32_t index, uint32_t& value);
  void SetParam(uint32_t index, string& value);
  void SetParam(uint32_t index, const string& value);

  bool ExecuteUpdate();
  CResultSet* ExecuteQuery();
  uint32_t GetInsertId();
private:
  MYSQL_STMT* m_stmt;
  MYSQL_BIND* m_param_bind;
  uint32_t    m_param_cnt;
};

class CDBPool;

/* 数据库连接对象 */
class CDBConn {
public:
  CDBConn(CDBPool* pDBPool);
  virtual ~CDBConn();
  int Init();

  CResultSet* ExecuteQuery(const char* sql_query);
  bool ExecuteUpdate(const char* sql_query);
  char* EscapeString(const char* content, uint32_t content_len);

  uint32_t GetInsertId();

  const char* GetPoolName();
  MYSQL* GetMysql() { return m_mysql; }
private:
  CDBPool*  m_pDBPool;	// to get MySQL server information
  MYSQL*    m_mysql;
  //MYSQL_RES* m_res;
  char      m_escape_string[MAX_ESCAPE_STRING_LEN + 1];
};


/* 数据库连接池 */
class CDBPool {
public:
  CDBPool(const char* pool_name, const char* db_server_ip, uint16_t db_server_port,
          const char* username, const char* password, const char* db_name, int max_conn_cnt);
  virtual ~CDBPool();

  int Init();
  CDBConn* GetDBConn();
  void RelDBConn(CDBConn* pConn);

  const char* GetPoolName() { return m_pool_name.c_str(); }
  const char* GetDBServerIP() { return m_db_server_ip.c_str(); }
  uint16_t GetDBServerPort() { return m_db_server_port; }
  const char* GetUsername() { return m_username.c_str(); }
  const char* GetPasswrod() { return m_password.c_str(); }
  const char* GetDBName() { return m_db_name.c_str(); }
private:
  string    m_pool_name;
  string    m_db_server_ip;
  uint16_t  m_db_server_port;
  string    m_username;
  string    m_password;
  string    m_db_name;
  int       m_db_cur_conn_cnt;
  int       m_db_max_conn_cnt;
  list<CDBConn*> m_free_list;
  CThreadNotify  m_free_notify;
};

// manage db pool (master for write and slave for read)
/* 管理连接池(单例模式) */
class CDBManager {
public:
  virtual ~CDBManager();

  static CDBManager* getInstance();

  int Init();

  CDBConn* GetDBConn(const char* dbpool_name);
  void RelDBConn(CDBConn* pConn);
private:
  CDBManager();

private:
  static CDBManager*    s_db_manager;
  map<string, CDBPool*> m_dbpool_map;
};

#endif /* DBPOOL_H_ */

/* db_proxy_server - DBPool.cpp */
#include "DBPool.h"
#include "ConfigFileReader.h"

#define MIN_DB_CONN_CNT		2

CDBManager* CDBManager::s_db_manager = NULL;

/* CResultSet 构造函数,构造MYSQL资源对象(即MYSQL的查询执行结果)
 * mysql_num_fields() 函数返回结果集中字段的数.
 * mysql_fetch_fields(res) - 获取表字段字符串数组MYSQL_FIELD的指针.
 * 将表字段名和对应的下标位置插入到 m_key_map.
 */
CResultSet::CResultSet(MYSQL_RES* res)
{
  m_res = res;

  // map table field key to index in the result array
  int num_fields = mysql_num_fields(m_res);
  MYSQL_FIELD* fields = mysql_fetch_fields(m_res);
  for(int i = 0; i < num_fields; i++)
  {
    m_key_map.insert(make_pair(fields[i].name, i));
  }
}

/* 释放MYSQL资源 */
CResultSet::~CResultSet()
{
  if (m_res) {
    mysql_free_result(m_res);
    m_res = NULL;
  }
}

/* mysql_fetch_row(res) - Retrieves the next row of a result set.
 * 获取MYSQL执行结果的下一行. 指针会依次从row[0]遍历到row[num_fields-1].
 */
bool CResultSet::Next()
{
  m_row = mysql_fetch_row(m_res);
  if (m_row) {
    return true;
  } else {
    return false;
  }
}

/* 取构造函数中初始化<表字段,下标> m_key_map 中对应字段的下标位置. */
int CResultSet::_GetIndex(const char* key)
{
  map<string, int>::iterator it = m_key_map.find(key);
  if (it == m_key_map.end()) {
    return -1;
  } else {
    return it->second;
  }
}

/* 根据表字段下标值,获取该下标的行数据(整形). */
int CResultSet::GetInt(const char* key)
{
  int idx = _GetIndex(key);
  if (idx == -1) {
    return 0;
  } else {
    return atoi(m_row[idx]);
  }
}

/* 根据表字段下标值,获取该下标的行数据(字符串). */
char* CResultSet::GetString(const char* key)
{
  int idx = _GetIndex(key);
  if (idx == -1) {
    return NULL;
  } else {
    return m_row[idx];
  }
}

/////////////////////////////////////////
CPrepareStatement::CPrepareStatement()
{
  m_stmt = NULL;
  m_param_bind = NULL;
  m_param_cnt = 0;
}

CPrepareStatement::~CPrepareStatement()
{
  if (m_stmt) {
    mysql_stmt_close(m_stmt);
    m_stmt = NULL;
  }

  if (m_param_bind) {
    delete [] m_param_bind;
    m_param_bind = NULL;
  }
}

/* mysql_ping() - Checks whether the connection to the server is working.
 * mysql_stmt_init(mysql) - Allocates memory for a MYSQL_STMT structure and initializes it.
 * mysql_stmt_prepare(...) - Prepares an SQL statement string for execution.
 * mysql_stmt_param_count(stmt) - Returns the number of parameters in a prepared statement.
 * memset(m_param_bind, 0, sizeof(MYSQL_BIND) * m_param_cnt); 置零,m_param_bind是输入输出参数.
 */
bool CPrepareStatement::Init(MYSQL* mysql, string& sql)
{
  mysql_ping(mysql);

  m_stmt = mysql_stmt_init(mysql);
  if (!m_stmt) {
    log("mysql_stmt_init failed");
    return false;
  }

  if (mysql_stmt_prepare(m_stmt, sql.c_str(), sql.size())) {
    log("mysql_stmt_prepare failed: %s", mysql_stmt_error(m_stmt));
    return false;
  }

  m_param_cnt = mysql_stmt_param_count(m_stmt);
  if (m_param_cnt > 0) {
    m_param_bind = new MYSQL_BIND [m_param_cnt];
    if (!m_param_bind) {
      log("new failed");
      return false;
    }

    memset(m_param_bind, 0, sizeof(MYSQL_BIND) * m_param_cnt);
  }

  return true;
}

void CPrepareStatement::SetParam(uint32_t index, int& value)
{
  if (index >= m_param_cnt) {
    log("index too large: %d", index);
    return;
  }

  m_param_bind[index].buffer_type = MYSQL_TYPE_LONG;
  m_param_bind[index].buffer = &value;
}

void CPrepareStatement::SetParam(uint32_t index, uint32_t& value)
{
  if (index >= m_param_cnt) {
    log("index too large: %d", index);
    return;
  }

  m_param_bind[index].buffer_type = MYSQL_TYPE_LONG;
  m_param_bind[index].buffer = &value;
}

void CPrepareStatement::SetParam(uint32_t index, string& value)
{
  if (index >= m_param_cnt) {
    log("index too large: %d", index);
    return;
  }

  m_param_bind[index].buffer_type = MYSQL_TYPE_STRING;
  m_param_bind[index].buffer = (char*)value.c_str();
  m_param_bind[index].buffer_length = value.size();
}

void CPrepareStatement::SetParam(uint32_t index, const string& value)
{
  if (index >= m_param_cnt) {
    log("index too large: %d", index);
    return;
  }

  m_param_bind[index].buffer_type = MYSQL_TYPE_STRING;
  m_param_bind[index].buffer = (char*)value.c_str();
  m_param_bind[index].buffer_length = value.size();
}

/* CPrepareStatement::SetParam() 给m_param_bind设置执行sql语句参数.
 * mysql_stmt_bind_param() 绑定参数.
 * mysql_stmt_execute() 执行sql语句.
 * mysql_stmt_affected_rows() 返回执行sql的执行效果.
 */
bool CPrepareStatement::ExecuteUpdate()
{
  if (!m_stmt) {
    log("no m_stmt");
    return false;
  }

  if (mysql_stmt_bind_param(m_stmt, m_param_bind)) {
    log("mysql_stmt_bind_param failed: %s", mysql_stmt_error(m_stmt));
    return false;
  }

  if (mysql_stmt_execute(m_stmt)) {
    log("mysql_stmt_execute failed: %s", mysql_stmt_error(m_stmt));
    return false;
  }

  if (mysql_stmt_affected_rows(m_stmt) == 0) {
    log("ExecuteUpdate have no effect");
    return false;
  }

  return true;
}

/* mysql_stmt_bind_param() 绑定m_param_bind参数.
 * mysql_stmt_execute() 执行sql语句,返回执行状态.
 * mysql_stmt_result_metadata()返回执行结果 MYSQL_RES* 指针.
 * new CResultSet(res), 初始化CResultSet对象.
 */
CResultSet* CPrepareStatement::ExecuteQuery() {

  if(!m_stmt) {
    log("no m_stmt");
    return NULL;
  }

  if (mysql_stmt_bind_param(m_stmt, m_param_bind)) {
    log("mysql_stmt_bind_param failed: %s", mysql_stmt_error(m_stmt));
    return NULL;
  }

  if (mysql_stmt_execute(m_stmt)) {
    log("mysql_stmt_execute failed: %s", mysql_stmt_error(m_stmt));
    return NULL;
  }

  MYSQL_RES* res = mysql_stmt_result_metadata(m_stmt);
  if (!res) {
    log("mysql_stmt_result_metadata failed: %s", mysql_stmt_error(m_stmt));
    return NULL;
  }

  CResultSet* result_set = new CResultSet(res);
  return result_set;

}

uint32_t CPrepareStatement::GetInsertId()
{
  return mysql_stmt_insert_id(m_stmt);
}

/////////////////////
CDBConn::CDBConn(CDBPool* pPool)
{
  m_pDBPool = pPool;
  m_mysql = NULL;
}

CDBConn::~CDBConn()
{
}

/* mysql_init() - Allocates or initializes a MYSQL object suitable for mysql_real_connect(). 
 * 初始化MYSQL示例,适配mysql_real_connect()函数建立连接.连接句柄是m_mysql.
 */ 
int CDBConn::Init()
{
  m_mysql = mysql_init(NULL);
  if (!m_mysql) {
    log("mysql_init failed");
    return 1;
  }

  my_bool reconnect = true;
  mysql_options(m_mysql, MYSQL_OPT_RECONNECT, &reconnect);
  mysql_options(m_mysql, MYSQL_SET_CHARSET_NAME, "utf8mb4");

  if (!mysql_real_connect(m_mysql, m_pDBPool->GetDBServerIP(), m_pDBPool->GetUsername(), m_pDBPool->GetPasswrod(),
        m_pDBPool->GetDBName(), m_pDBPool->GetDBServerPort(), NULL, 0)) {
    log("mysql_real_connect failed: %s", mysql_error(m_mysql));
    return 2;
  }

  return 0;
}

const char* CDBConn::GetPoolName()
{
  return m_pDBPool->GetPoolName();
}

/* mysql_real_query() 执行sql语句.
 * mysql_store_result() 返回执行结果保存在 MYSQL_RES* 中.
 */
CResultSet* CDBConn::ExecuteQuery(const char* sql_query)
{
  mysql_ping(m_mysql);

  if (mysql_real_query(m_mysql, sql_query, strlen(sql_query))) {
    log("mysql_real_query failed: %s, sql: %s", mysql_error(m_mysql), sql_query);
    return NULL;
  }

  MYSQL_RES* res = mysql_store_result(m_mysql);
  if (!res) {
    log("mysql_store_result failed: %s", mysql_error(m_mysql));
    return NULL;
  }

  CResultSet* result_set = new CResultSet(res);
  return result_set;
}

/* 执行sql语句,mysql_affected_rows()判断是否生效. */
bool CDBConn::ExecuteUpdate(const char* sql_query)
{
  mysql_ping(m_mysql);

  if (mysql_real_query(m_mysql, sql_query, strlen(sql_query))) {
    log("mysql_real_query failed: %s, sql: %s", mysql_error(m_mysql), sql_query);
    return false;
  }

  if (mysql_affected_rows(m_mysql) > 0) {
    return true;
  } else {
    return false;
  }
}

/* mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符,防注入攻击 */
char* CDBConn::EscapeString(const char* content, uint32_t content_len)
{
  if (content_len > (MAX_ESCAPE_STRING_LEN >> 1)) {
    m_escape_string[0] = 0;
  } else {
    mysql_real_escape_string(m_mysql, m_escape_string, content, content_len);
  }

  return m_escape_string;
}

uint32_t CDBConn::GetInsertId()
{
  return (uint32_t)mysql_insert_id(m_mysql);
}

////////////////
CDBPool::CDBPool(const char* pool_name, const char* db_server_ip, uint16_t db_server_port,
    const char* username, const char* password, const char* db_name, int max_conn_cnt)
{
  m_pool_name = pool_name;
  m_db_server_ip = db_server_ip;
  m_db_server_port = db_server_port;
  m_username = username;
  m_password = password;
  m_db_name = db_name;
  m_db_max_conn_cnt = max_conn_cnt;
  m_db_cur_conn_cnt = MIN_DB_CONN_CNT;
}

CDBPool::~CDBPool()
{
  for (list<CDBConn*>::iterator it = m_free_list.begin(); it != m_free_list.end(); it++) {
    CDBConn* pConn = *it;
    delete pConn;
  }

  m_free_list.clear();
}

/* 初始化数据库连接池, new 连接资源CDBConn存入到m_free_list空闲MySQL连接队列 */
int CDBPool::Init()
{
  for (int i = 0; i < m_db_cur_conn_cnt; i++) {
    CDBConn* pDBConn = new CDBConn(this);
    int ret = pDBConn->Init();
    if (ret) {
      delete pDBConn;
      return ret;
    }

    m_free_list.push_back(pDBConn);
  }

  log("db pool: %s, size: %d", m_pool_name.c_str(), (int)m_free_list.size());
  return 0;
}

/*
 *TODO: 增加保护机制,把分配的连接加入另一个队列,这样获取连接时,如果没有空闲连接,
 *TODO: 检查已经分配的连接多久没有返回,如果超过一定时间,则自动收回连接,放在用户忘了调用释放连接的接口
 */
/* 取m_free_list空闲MySQL连接队列的连接, 如果m_free_list为空,则new一个连接.
 * 如果当前连接数大于最大连接数, 则挂起等待RelDBConn()回收资源.
 */
CDBConn* CDBPool::GetDBConn()
{
  m_free_notify.Lock();

  while (m_free_list.empty()) {
    if (m_db_cur_conn_cnt >= m_db_max_conn_cnt) {
      m_free_notify.Wait();
    } else {
      CDBConn* pDBConn = new CDBConn(this);
      int ret = pDBConn->Init();
      if (ret) {
        log("Init DBConnecton failed");
        delete pDBConn;
        m_free_notify.Unlock();
        return NULL;
      } else {
        m_free_list.push_back(pDBConn);
        m_db_cur_conn_cnt++;
        log("new db connection: %s, conn_cnt: %d", m_pool_name.c_str(), m_db_cur_conn_cnt);
      }
    }
  }

  CDBConn* pConn = m_free_list.front();
  m_free_list.pop_front();

  m_free_notify.Unlock();

  return pConn;
}

/* 回收MySQL连接资源,重新保存到m_free_list,
 * 同时发出条件变量信号.解除GetDBConn()的条件等待.
 * 如果所有的pConn连接资源重新回到m_free_list中, 析构操作可以完整释放内存.
 */
void CDBPool::RelDBConn(CDBConn* pConn)
{
  m_free_notify.Lock();

  list<CDBConn*>::iterator it = m_free_list.begin();
  for (; it != m_free_list.end(); it++) {
    if (*it == pConn) {
      break;
    }
  }

  if (it == m_free_list.end()) {
    m_free_list.push_back(pConn);
  }

  m_free_notify.Signal();
  m_free_notify.Unlock();
}

/////////////////
CDBManager::CDBManager()
{

}

CDBManager::~CDBManager()
{

}

/* 获取单例, 自动初始化MySQL连接池. */
CDBManager* CDBManager::getInstance()
{
  if (!s_db_manager) {
    s_db_manager = new CDBManager();
    if (s_db_manager->Init()) {
      delete s_db_manager;
      s_db_manager = NULL;
    }
  }

  return s_db_manager;
}
/*
 * 2015-01-12
 * modify by ZhangYuanhao :enable config the max connection of every instance
 *
 */
/*
 * 初始化 teamtalk_master,teamtalk_slave 2个MySQL连接池实例.
 */
int CDBManager::Init()
{
  CConfigFileReader config_file("dbproxyserver.conf");

  char* db_instances = config_file.GetConfigName("DBInstances");

  if (!db_instances) {
    log("not configure DBInstances");
    return 1;
  }

  char host[64];
  char port[64];
  char dbname[64];
  char username[64];
  char password[64];
  char maxconncnt[64];
  CStrExplode instances_name(db_instances, ',');

  for (uint32_t i = 0; i < instances_name.GetItemCnt(); i++) {
    char* pool_name = instances_name.GetItem(i);
    snprintf(host, 64, "%s_host", pool_name);
    snprintf(port, 64, "%s_port", pool_name);
    snprintf(dbname, 64, "%s_dbname", pool_name);
    snprintf(username, 64, "%s_username", pool_name);
    snprintf(password, 64, "%s_password", pool_name);
    snprintf(maxconncnt, 64, "%s_maxconncnt", pool_name);

    char* db_host = config_file.GetConfigName(host);
    char* str_db_port = config_file.GetConfigName(port);
    char* db_dbname = config_file.GetConfigName(dbname);
    char* db_username = config_file.GetConfigName(username);
    char* db_password = config_file.GetConfigName(password);
    char* str_maxconncnt = config_file.GetConfigName(maxconncnt);

    if (!db_host || !str_db_port || !db_dbname || !db_username || !db_password || !str_maxconncnt) {
      log("not configure db instance: %s", pool_name);
      return 2;
    }

    int db_port = atoi(str_db_port);
    int db_maxconncnt = atoi(str_maxconncnt);
    CDBPool* pDBPool = new CDBPool(pool_name, db_host, db_port, db_username, db_password, db_dbname, db_maxconncnt);
    if (pDBPool->Init()) {
      log("init db instance failed: %s", pool_name);
      return 3;
    }
    m_dbpool_map.insert(make_pair(pool_name, pDBPool));
  }

  return 0;
}

/* 获取连接池dbpool_name中一条MySQL连接资源 */
CDBConn* CDBManager::GetDBConn(const char* dbpool_name)
{
  map<string, CDBPool*>::iterator it = m_dbpool_map.find(dbpool_name);
  if (it == m_dbpool_map.end()) {
    return NULL;
  } else {
    return it->second->GetDBConn();
  }
}

/* 回收该MySQL连接资源 */
void CDBManager::RelDBConn(CDBConn* pConn)
{
  if (!pConn) {
    return;
  }

  map<string, CDBPool*>::iterator it = m_dbpool_map.find(pConn->GetPoolName());
  if (it != m_dbpool_map.end()) {
    it->second->RelDBConn(pConn);
  }
}

/* db_proxy_server - CachePool.h */
#ifndef CACHEPOOL_H_
#define CACHEPOOL_H_

#include <vector>
#include "../base/util.h"
#include "ThreadPool.h"
#include "hiredis.h"

class CachePool;

/* 在Redis的哈希表结构中,保存域名(field name)和域的值(value).
 * 例如:
 * 设置哈希表  key  - field - value 记录.
 * redis> HSET people jack "Jack Sparrow"
 * redis> HSET people gump "Forrest Gump"
 * 根据key取值
 * redis> HGETALL people
 * 1) "jack"          # 域(filed)
 * 2) "Jack Sparrow"  # 值(value)
 * 3) "gump"
 * 4) "Forrest Gump
 */
class CacheConn {
public:
  CacheConn(CachePool* pCachePool);
  virtual ~CacheConn();

  int Init();
  const char* GetPoolName();

  string get(string key);
  string setex(string key, int timeout, string value);
  string set(string key, string& value);

  //批量获取
  bool mget(const vector<string>& keys, map<string, string>& ret_value);
  // 判断一个key是否存在
  bool isExists(string &key);

  // Redis hash structure
  long hdel(string key, string field);
  string hget(string key, string field);
  bool hgetAll(string key, map<string, string>& ret_value);
  long hset(string key, string field, string value);

  long hincrBy(string key, string field, long value);
  long incrBy(string key, long value);
  string hmset(string key, map<string, string>& hash);
  bool hmget(string key, list<string>& fields, list<string>& ret_value);

  //原子加减1
  long incr(string key);
  long decr(string key);

  // Redis list structure
  long lpush(string key, string value);
  long rpush(string key, string value);
  long llen(string key);
  bool lrange(string key, long start, long end, list<string>& ret_value);

private:
  CachePool*    m_pCachePool;
  redisContext* m_pContext;
  uint64_t      m_last_connect_time;
};

class CachePool {
public:
  CachePool(const char* pool_name, const char* server_ip,
            int server_port, int db_num, int max_conn_cnt);
  virtual ~CachePool();

  int Init();

  CacheConn* GetCacheConn();
  void RelCacheConn(CacheConn* pCacheConn);

  const char* GetPoolName() { return m_pool_name.c_str(); }
  const char* GetServerIP() { return m_server_ip.c_str(); }
  int GetServerPort() { return m_server_port; }
  int GetDBNum() { return m_db_num; }
private:
  string m_pool_name;
  string m_server_ip;
  int    m_server_port;
  int    m_db_num;

  int    m_cur_conn_cnt;
  int    m_max_conn_cnt;
  list<CacheConn*> m_free_list;
  CThreadNotify    m_free_notify;
};

class CacheManager {
public:
  virtual ~CacheManager();

  static CacheManager* getInstance();

  int Init();
  CacheConn* GetCacheConn(const char* pool_name);
  void RelCacheConn(CacheConn* pCacheConn);
private:
  CacheManager();

private:
  static CacheManager*    s_cache_manager;
  map<string, CachePool*>	m_cache_pool_map;
};

#endif /* CACHEPOOL_H_ */

/* db_proxy_server - CachePool.cpp */
#include "CachePool.h"
#include "ConfigFileReader.h"

#define MIN_CACHE_CONN_CNT	2

CacheManager* CacheManager::s_cache_manager = NULL;

CacheConn::CacheConn(CachePool* pCachePool)
{
  m_pCachePool = pCachePool;
  m_pContext = NULL;
  m_last_connect_time = 0;
}

CacheConn::~CacheConn()
{
  if (m_pContext) {
    redisFree(m_pContext);
    m_pContext = NULL;
  }
}

/* redis初始化连接和重连操作
 * redisConnectWithTimeout() 返回一个Redis连接句柄redisContext *m_pContext,
 * 其 redisContext 数据结构的内部实现是套接字socket, 即返回一个连接套接字connfd.
 */
int CacheConn::Init()
{
  if (m_pContext) {
    return 0;
  }

  // 4s 尝试重连一次
  uint64_t cur_time = (uint64_t)time(NULL);
  if (cur_time < m_last_connect_time + 4) {
    return 1;
  }

  m_last_connect_time = cur_time;

  // 200ms超时
  struct timeval timeout = {0, 200000};
  m_pContext = redisConnectWithTimeout(m_pCachePool->GetServerIP(), m_pCachePool->GetServerPort(), timeout);
  if (!m_pContext || m_pContext->err) {
    if (m_pContext) {
      log("redisConnect failed: %s", m_pContext->errstr);
      redisFree(m_pContext);
      m_pContext = NULL;
    } else {
      log("redisConnect failed");
    }

    return 1;
  }

  redisReply* reply = (redisReply *)redisCommand(m_pContext, "SELECT %d", m_pCachePool->GetDBNum());
  if (reply && (reply->type == REDIS_REPLY_STATUS) && (strncmp(reply->str, "OK", 2) == 0)) {
    freeReplyObject(reply);
    return 0;
  } else {
    log("select cache db failed");
    return 2;
  }
}


const char* CacheConn::GetPoolName()
{
  return m_pCachePool->GetPoolName();
}

/* get 命令, 成功返回"OK" */
string CacheConn::get(string key)
{
  string value;

  if (Init()) {
    return value;
  }

  redisReply* reply = (redisReply *)redisCommand(m_pContext, "GET %s", key.c_str());
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return value;
  }

  if (reply->type == REDIS_REPLY_STRING) {
    value.append(reply->str, reply->len);
  }

  freeReplyObject(reply);
  return value;
}

/* SETEX 命令 - 设置生存时间,成功返回"OK" */
string CacheConn::setex(string key, int timeout, string value)
{
  string ret_value;

  if (Init()) {
    return ret_value;
  }

  redisReply* reply = (redisReply *)redisCommand(m_pContext, "SETEX %s %d %s", key.c_str(), timeout, value.c_str());
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return ret_value;
  }

  ret_value.append(reply->str, reply->len);
  freeReplyObject(reply);
  return ret_value;
}

/* set 命令, 成功返回"OK". */
string CacheConn::set(string key, string &value)
{
  string ret_value;

  if (Init()) {
    return ret_value;
  }

  redisReply* reply = (redisReply *)redisCommand(m_pContext, "SET %s %s", key.c_str(), value.c_str());
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return ret_value;
  }

  ret_value.append(reply->str, reply->len);
  freeReplyObject(reply);
  return ret_value;
}

/* 批量get字符串数组keys的每个字符串的value值, 一一对应保存在ret_value中. */
bool CacheConn::mget(const vector<string>& keys, map<string, string>& ret_value)
{
  if(Init())
  {
    return false;
  }
  if(keys.empty())
  {
    return false;
  }

  string strKey;
  bool bFirst = true;
  for (vector<string>::const_iterator it=keys.begin(); it!=keys.end(); ++it) {
    if(bFirst)
    {
      bFirst = false;
      strKey = *it;
    }
    else
    {
      strKey += " " + *it;
    }
  }

  if(strKey.empty())
  {
    return false;
  }
  strKey = "MGET " + strKey;
  redisReply* reply = (redisReply*) redisCommand(m_pContext, strKey.c_str());
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return false;
  }
  if(reply->type == REDIS_REPLY_ARRAY)
  {
    for(size_t i=0; i<reply->elements; ++i)
    {
      redisReply* child_reply = reply->element[i];
      if (child_reply->type == REDIS_REPLY_STRING) {
        ret_value[keys[i]] = child_reply->str;
      }
    }
  }
  freeReplyObject(reply);
  return true;
}

/* key是否已存在. */
bool CacheConn::isExists(string &key)
{
  if (Init()) {
    return false;
  }

  redisReply* reply = (redisReply*) redisCommand(m_pContext, "EXISTS %s", key.c_str());
  if(!reply)
  {
    log("redisCommand failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    return false;
  }
  long ret_value = reply->integer;
  freeReplyObject(reply);
  if(0 == ret_value)
  {
    return false;
  }
  else
  {
    return true;
  }
}

/* 删除哈希表 key 中的一个或多个指定域,不存在的域将被忽略.返回成功移除的数量 */
long CacheConn::hdel(string key, string field)
{
  if (Init()) {
    return 0;
  }

  redisReply* reply = (redisReply *)redisCommand(m_pContext, "HDEL %s %s", key.c_str(), field.c_str());
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return 0;
  }

  long ret_value = reply->integer;
  freeReplyObject(reply);
  return ret_value;
}

/* 返回哈希表中给定域的值,成功返回"OK" */
string CacheConn::hget(string key, string field)
{
  string ret_value;
  if (Init()) {
    return ret_value;
  }

  redisReply* reply = (redisReply *)redisCommand(m_pContext, "HGET %s %s", key.c_str(), field.c_str());
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return ret_value;
  }

  if (reply->type == REDIS_REPLY_STRING) {
    ret_value.append(reply->str, reply->len);
  }

  freeReplyObject(reply);
  return ret_value;
}

/* 返回哈希表 key 中,所有的域和值. */
bool CacheConn::hgetAll(string key, map<string, string>& ret_value)
{
  if (Init()) {
    return false;
  }

  redisReply* reply = (redisReply *)redisCommand(m_pContext, "HGETALL %s", key.c_str());
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return false;
  }

  if ( (reply->type == REDIS_REPLY_ARRAY) && (reply->elements % 2 == 0) ) {
    for (size_t i = 0; i < reply->elements; i += 2) {
      redisReply* field_reply = reply->element[i];
      redisReply* value_reply = reply->element[i + 1];

      string field(field_reply->str, field_reply->len);
      string value(value_reply->str, value_reply->len);
      ret_value.insert(make_pair(field, value));
    }
  }

  freeReplyObject(reply);
  return true;
}

/* 将哈希表 hash 中 key 在域 field 的值设置为 value */
long CacheConn::hset(string key, string field, string value)
{
  if (Init()) {
    return -1;
  }

  redisReply* reply = (redisReply *)redisCommand(m_pContext, "HSET %s %s %s", key.c_str(), field.c_str(), value.c_str());
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return -1;
  }

  long ret_value = reply->integer;
  freeReplyObject(reply);
  return ret_value;
}

/* 为哈希表 key 中的域 field 的值加上增量 value */
long CacheConn::hincrBy(string key, string field, long value)
{
  if (Init()) {
    return -1;
  }

  redisReply* reply = (redisReply *)redisCommand(m_pContext, "HINCRBY %s %s %ld", key.c_str(), field.c_str(), value);
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return -1;
  }

  long ret_value = reply->integer;
  freeReplyObject(reply);
  return ret_value;
}

long CacheConn::incrBy(string key, long value)
{
  if(Init())
  {
    return -1;
  }

  redisReply* reply = (redisReply*)redisCommand(m_pContext, "INCRBY %s %ld", key.c_str(), value);
  if(!reply)
  {
    log("redis Command failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return -1;
  }
  long ret_value = reply->integer;
  freeReplyObject(reply);
  return ret_value;
}

/* 同时将多个 field-value (域-值)对设置到哈希表 key 中. */
string CacheConn::hmset(string key, map<string, string>& hash)
{
  string ret_value;

  if (Init()) {
    return ret_value;
  }

  int argc = hash.size() * 2 + 2;
  const char** argv = new const char* [argc];
  if (!argv) {
    return ret_value;
  }

  argv[0] = "HMSET";
  argv[1] = key.c_str();
  int i = 2;
  for (map<string, string>::iterator it = hash.begin(); it != hash.end(); it++) {
    argv[i++] = it->first.c_str();
    argv[i++] = it->second.c_str();
  }

  redisReply* reply = (redisReply *)redisCommandArgv(m_pContext, argc, argv, NULL);
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    delete [] argv;

    redisFree(m_pContext);
    m_pContext = NULL;
    return ret_value;
  }

  ret_value.append(reply->str, reply->len);

  delete [] argv;
  freeReplyObject(reply);
  return ret_value;
}

bool CacheConn::hmget(string key, list<string>& fields, list<string>& ret_value)
{
  if (Init()) {
    return false;
  }

  int argc = fields.size() + 2;
  const char** argv = new const char* [argc];
  if (!argv) {
    return false;
  }

  argv[0] = "HMGET";
  argv[1] = key.c_str();
  int i = 2;
  for (list<string>::iterator it = fields.begin(); it != fields.end(); it++) {
    argv[i++] = it->c_str();
  }

  redisReply* reply = (redisReply *)redisCommandArgv(m_pContext, argc, (const char**)argv, NULL);
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    delete [] argv;

    redisFree(m_pContext);
    m_pContext = NULL;

    return false;
  }

  if (reply->type == REDIS_REPLY_ARRAY) {
    for (size_t i = 0; i < reply->elements; i++) {
      redisReply* value_reply = reply->element[i];
      string value(value_reply->str, value_reply->len);
      ret_value.push_back(value);
    }
  }

  delete [] argv;
  freeReplyObject(reply);
  return true;
}

long CacheConn::incr(string key)
{
  if(Init())
  {
    return -1;
  }

  redisReply* reply = (redisReply*)redisCommand(m_pContext, "INCR %s", key.c_str());
  if(!reply)
  {
    log("redis Command failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return -1;
  }
  long ret_value = reply->integer;
  freeReplyObject(reply);
  return ret_value;
}

long CacheConn::decr(string key)
{
  if(Init())
  {
    return -1;
  }

  redisReply* reply = (redisReply*)redisCommand(m_pContext, "DECR %s", key.c_str());
  if(!reply)
  {
    log("redis Command failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return -1;
  }
  long ret_value = reply->integer;
  freeReplyObject(reply);
  return ret_value;
}

/* 将一个或多个值 value 插入到列表 key 的表头 */
long CacheConn::lpush(string key, string value)
{
  if (Init()) {
    return -1;
  }

  redisReply* reply = (redisReply *)redisCommand(m_pContext, "LPUSH %s %s", key.c_str(), value.c_str());
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return -1;
  }

  long ret_value = reply->integer;
  freeReplyObject(reply);
  return ret_value;
}

/* 将一个或多个值 value 插入到列表 key 的表尾(最右边). */
long CacheConn::rpush(string key, string value)
{
  if (Init()) {
    return -1;
  }

  redisReply* reply = (redisReply *)redisCommand(m_pContext, "RPUSH %s %s", key.c_str(), value.c_str());
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return -1;
  }

  long ret_value = reply->integer;
  freeReplyObject(reply);
  return ret_value;
}

/* 返回列表 key 的长度 */
long CacheConn::llen(string key)
{
  if (Init()) {
    return -1;
  }

  redisReply* reply = (redisReply *)redisCommand(m_pContext, "LLEN %s", key.c_str());
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return -1;
  }

  long ret_value = reply->integer;
  freeReplyObject(reply);
  return ret_value;
}

/* 返回列表 key 中指定区间内的元素,区间以偏移量 start 和 stop 指定. */
bool CacheConn::lrange(string key, long start, long end, list<string>& ret_value)
{
  if (Init()) {
    return false;
  }

  redisReply* reply = (redisReply *)redisCommand(m_pContext, "LRANGE %s %d %d", key.c_str(), start, end);
  if (!reply) {
    log("redisCommand failed:%s", m_pContext->errstr);
    redisFree(m_pContext);
    m_pContext = NULL;
    return false;
  }

  if (reply->type == REDIS_REPLY_ARRAY) {
    for (size_t i = 0; i < reply->elements; i++) {
      redisReply* value_reply = reply->element[i];
      string value(value_reply->str, value_reply->len);
      ret_value.push_back(value);
    }
  }

  freeReplyObject(reply);
  return true;
}

///////////////
CachePool::CachePool(const char* pool_name, const char* server_ip, int server_port, int db_num, int max_conn_cnt)
{
  m_pool_name = pool_name;
  m_server_ip = server_ip;
  m_server_port = server_port;
  m_db_num = db_num;
  m_max_conn_cnt = max_conn_cnt;
  m_cur_conn_cnt = MIN_CACHE_CONN_CNT; //当前连接数设置为最小连接.
}

/* 释放m_free_list连接队列, m_free_list是空闲Redis连接资源(未被取用) */
CachePool::~CachePool()
{
  m_free_notify.Lock();
  for (list<CacheConn*>::iterator it = m_free_list.begin(); it != m_free_list.end(); it++) {
    CacheConn* pConn = *it;
    delete pConn;
  }

  m_free_list.clear();
  m_cur_conn_cnt = 0;
  m_free_notify.Unlock();
}

/* 初始化缓存池, 只分配最少连接数到m_free_list连接队列. */
int CachePool::Init()
{
  for (int i = 0; i < m_cur_conn_cnt; i++) {
    CacheConn* pConn = new CacheConn(this);
    if (pConn->Init()) {
      delete pConn;
      return 1;
    }

    m_free_list.push_back(pConn);
  }

  log("cache pool: %s, list size: %lu", m_pool_name.c_str(), m_free_list.size());
  return 0;
}

/* 从 m_free_list资源队列获取Redis连接资源.
 * 如果队列为空, new 一个新的连接资源.
 * 如果当前连接数大于等于最大连接数,使用调节变量等待RelCacheConn()进行资源回收.
 */
CacheConn* CachePool::GetCacheConn()
{
  m_free_notify.Lock();

  while (m_free_list.empty()) {
    if (m_cur_conn_cnt >= m_max_conn_cnt) {
      m_free_notify.Wait();
    } else {
      CacheConn* pCacheConn = new CacheConn(this);
      int ret = pCacheConn->Init();
      if (ret) {
        log("Init CacheConn failed");
        delete pCacheConn;
        m_free_notify.Unlock();
        return NULL;
      } else {
        m_free_list.push_back(pCacheConn);
        m_cur_conn_cnt++;
        log("new cache connection: %s, conn_cnt: %d", m_pool_name.c_str(), m_cur_conn_cnt);
      }
    }
  }

  CacheConn* pConn = m_free_list.front();
  m_free_list.pop_front();

  m_free_notify.Unlock();

  return pConn;
}

/* 回收 Redis缓存连接 保存到 m_free_list 资源队列.
 * 同时释放条件变量信号, 解除 GetCacheConn() 中的等待信号.
 */
void CachePool::RelCacheConn(CacheConn* pCacheConn)
{
  m_free_notify.Lock();

  list<CacheConn*>::iterator it = m_free_list.begin();
  for (; it != m_free_list.end(); it++) {
    if (*it == pCacheConn) {
      break;
    }
  }

  if (it == m_free_list.end()) {
    m_free_list.push_back(pCacheConn);
  }

  m_free_notify.Signal();
  m_free_notify.Unlock();
}

///////////
CacheManager::CacheManager()
{

}

CacheManager::~CacheManager()
{

}

/* 获取单例, 自动初始化Redis连接池. */
CacheManager* CacheManager::getInstance()
{
  if (!s_cache_manager) {
    s_cache_manager = new CacheManager();
    if (s_cache_manager->Init()) {
      delete s_cache_manager;
      s_cache_manager = NULL;
    }
  }

  return s_cache_manager;
}

/* 取配置文件,初始化unread,group_set,token,sync,group_member 5个缓存池
 * 保存在 m_cache_pool_map缓存池map中.
 */
int CacheManager::Init()
{
  CConfigFileReader config_file("dbproxyserver.conf");

  char* cache_instances = config_file.GetConfigName("CacheInstances");
  if (!cache_instances) {
    log("not configure CacheIntance");
    return 1;
  }

  char host[64];
  char port[64];
  char db[64];
  char maxconncnt[64];
  CStrExplode instances_name(cache_instances, ',');
  for (uint32_t i = 0; i < instances_name.GetItemCnt(); i++) {
    char* pool_name = instances_name.GetItem(i);
    //printf("%s", pool_name);
    snprintf(host, 64, "%s_host", pool_name);
    snprintf(port, 64, "%s_port", pool_name);
    snprintf(db, 64, "%s_db", pool_name);
    snprintf(maxconncnt, 64, "%s_maxconncnt", pool_name);

    char* cache_host = config_file.GetConfigName(host);
    char* str_cache_port = config_file.GetConfigName(port);
    char* str_cache_db = config_file.GetConfigName(db);
    char* str_max_conn_cnt = config_file.GetConfigName(maxconncnt);
    if (!cache_host || !str_cache_port || !str_cache_db || !str_max_conn_cnt) {
      log("not configure cache instance: %s", pool_name);
      return 2;
    }

    CachePool* pCachePool = new CachePool(pool_name, cache_host, atoi(str_cache_port),
        atoi(str_cache_db), atoi(str_max_conn_cnt));
    if (pCachePool->Init()) {
      log("Init cache pool failed");
      return 3;
    }

    m_cache_pool_map.insert(make_pair(pool_name, pCachePool));
  }

  return 0;
}

/* 获取缓存池 pool_name 中一条Redis连接. */
CacheConn* CacheManager::GetCacheConn(const char* pool_name)
{
  map<string, CachePool*>::iterator it = m_cache_pool_map.find(pool_name);
  if (it != m_cache_pool_map.end()) {
    return it->second->GetCacheConn();
  } else {
    return NULL;
  }
}

/* 返回Redis连接资源. */
void CacheManager::RelCacheConn(CacheConn* pCacheConn)
{
  if (!pCacheConn) {
    return;
  }

  map<string, CachePool*>::iterator it = m_cache_pool_map.find(pCacheConn->GetPoolName());
  if (it != m_cache_pool_map.end()) {
    return it->second->RelCacheConn(pCacheConn);
  }
}

/* db_proxy_server - AutoPool.h */
#ifndef __AUTOPOOl_H__
#define __AUTOPOOl_H__

class CDBConn;
class CacheConn;

/* RAII手法
 * 构造函数自动取一条 MySQL 连接(MySQL的连接资源),使用完之后自动释放.
 * 构造函数自动取一条 Redis 连接(Redis的缓存资源),使用完之后自动释放.
 */
class CAutoDB
{
public:
    CAutoDB(const char* pDBName, CDBConn** pDBConn);
    ~CAutoDB();
private:
    CDBConn* m_pDBConn;
};

class CAutoCache
{
    CAutoCache(const char* pCacheName, CacheConn** pCacheConn);
    ~CAutoCache();
private:
    CacheConn* m_pCacheConn;
};
#endif /*defined(__AUTOPOOl_H__) */

/* db_proxy_server - AutoPool.cpp */
#include "AutoPool.h"
#include "DBPool.h"
#include "CachePool.h"

CAutoDB::CAutoDB(const char* pDBName, CDBConn** pDBConn)
{
    m_pDBConn = CDBManager::getInstance()->GetDBConn(pDBName);
    *pDBConn = m_pDBConn;
}

CAutoDB::~CAutoDB()
{
    if (m_pDBConn != NULL) {
        CDBManager::getInstance()->RelDBConn(m_pDBConn);
        m_pDBConn = NULL;
    }
}

CAutoCache::CAutoCache(const char* pCacheName, CacheConn** pCacheConn)
{
    m_pCacheConn = CacheManager::getInstance()->GetCacheConn(pCacheName);
    *pCacheConn = m_pCacheConn;
}

CAutoCache::~CAutoCache()
{
    if (m_pCacheConn != NULL) {
        CacheManager::getInstance()->RelCacheConn(m_pCacheConn);
        m_pCacheConn = NULL;
    }
}

/* db_proxy_server - HandlerMap.h */
#ifndef HANDLERMAP_H_
#define HANDLERMAP_H_

#include "../base/util.h"
#include "ProxyTask.h"

typedef map<uint32_t, pdu_handler_t> HandlerMap_t;

/* 加载 commandId 对应的处理函数 */
class CHandlerMap {
public:
  virtual ~CHandlerMap();

  static CHandlerMap* getInstance();
  void Init();

  pdu_handler_t GetHandler(uint32_t pdu_type);

private:
  CHandlerMap();

private:
  static CHandlerMap* s_handler_instance;
  HandlerMap_t m_handler_map;
};

#endif /* HANDLERMAP_H_ */

/* db_proxy_server - HandlerMap.cpp */
#include "HandlerMap.h"
#include "business/Login.h"
#include "business/MessageContent.h"
#include "business/RecentSession.h"
#include "business/UserAction.h"
#include "business/MessageCounter.h"
#include "business/GroupAction.h"
#include "business/DepartAction.h"
#include "business/FileAction.h"
#include "IM.BaseDefine.pb.h"

using namespace IM::BaseDefine;

CHandlerMap* CHandlerMap::s_handler_instance = NULL;

/* 构造函数 */
CHandlerMap::CHandlerMap()
{

}

/* 析构函数 */
CHandlerMap::~CHandlerMap()
{

}

/* 返回指向CHandlerMap的单例指针 */
CHandlerMap* CHandlerMap::getInstance()
{
  if (!s_handler_instance) {
    s_handler_instance = new CHandlerMap();
    s_handler_instance->Init();
  }

  return s_handler_instance;
}

/* 初始化函数,加载了各种commandId 对应的处理函数 */
void CHandlerMap::Init()
{
  // Login validate
  m_handler_map.insert(make_pair(uint32_t(CID_OTHER_VALIDATE_REQ), DB_PROXY::doLogin));
  m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_PUSH_SHIELD), DB_PROXY::doPushShield));
  m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_QUERY_PUSH_SHIELD), DB_PROXY::doQueryPushShield));

  // recent session
  m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST), DB_PROXY::getRecentSession));
  m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_REMOVE_SESSION_REQ), DB_PROXY::deleteRecentSession));

  // users
  m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_USER_INFO_REQUEST), DB_PROXY::getUserInfo));
  m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_ALL_USER_REQUEST), DB_PROXY::getChangedUser));
  m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_DEPARTMENT_REQUEST), DB_PROXY::getChgedDepart));
  m_handler_map.insert(make_pair(uint32_t(CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST), DB_PROXY::changeUserSignInfo));

  // message content
  m_handler_map.insert(make_pair(uint32_t(CID_MSG_DATA), DB_PROXY::sendMessage));
  m_handler_map.insert(make_pair(uint32_t(CID_MSG_LIST_REQUEST), DB_PROXY::getMessage));
  m_handler_map.insert(make_pair(uint32_t(CID_MSG_UNREAD_CNT_REQUEST), DB_PROXY::getUnreadMsgCounter));
  m_handler_map.insert(make_pair(uint32_t(CID_MSG_READ_ACK), DB_PROXY::clearUnreadMsgCounter));
  m_handler_map.insert(make_pair(uint32_t(CID_MSG_GET_BY_MSG_ID_REQ), DB_PROXY::getMessageById));
  m_handler_map.insert(make_pair(uint32_t(CID_MSG_GET_LATEST_MSG_ID_REQ), DB_PROXY::getLatestMsgId));

  // device token
  m_handler_map.insert(make_pair(uint32_t(CID_LOGIN_REQ_DEVICETOKEN), DB_PROXY::setDevicesToken));
  m_handler_map.insert(make_pair(uint32_t(CID_OTHER_GET_DEVICE_TOKEN_REQ), DB_PROXY::getDevicesToken));

  //push 推送设置
  m_handler_map.insert(make_pair(uint32_t(CID_GROUP_SHIELD_GROUP_REQUEST), DB_PROXY::setGroupPush));
  m_handler_map.insert(make_pair(uint32_t(CID_OTHER_GET_SHIELD_REQ), DB_PROXY::getGroupPush));

  // group
  m_handler_map.insert(make_pair(uint32_t(CID_GROUP_NORMAL_LIST_REQUEST), DB_PROXY::getNormalGroupList));
  m_handler_map.insert(make_pair(uint32_t(CID_GROUP_INFO_REQUEST), DB_PROXY::getGroupInfo));
  m_handler_map.insert(make_pair(uint32_t(CID_GROUP_CREATE_REQUEST), DB_PROXY::createGroup));
  m_handler_map.insert(make_pair(uint32_t(CID_GROUP_CHANGE_MEMBER_REQUEST), DB_PROXY::modifyMember));

  // file
  m_handler_map.insert(make_pair(uint32_t(CID_FILE_HAS_OFFLINE_REQ), DB_PROXY::hasOfflineFile));
  m_handler_map.insert(make_pair(uint32_t(CID_FILE_ADD_OFFLINE_REQ), DB_PROXY::addOfflineFile));
  m_handler_map.insert(make_pair(uint32_t(CID_FILE_DEL_OFFLINE_REQ), DB_PROXY::delOfflineFile));
}

/* 通过commandId获取处理函数
 * @param pdu_type commandId
 * @return 处理函数的函数指针
 */
pdu_handler_t CHandlerMap::GetHandler(uint32_t pdu_type)
{
  HandlerMap_t::iterator it = m_handler_map.find(pdu_type);
  if (it != m_handler_map.end()) {
    return it->second;
  } else {
    return NULL;
  }
}

/* db_proxy_server - ProxyTask.h */
#ifndef __PROXY_TASK_H__
#define __PROXY_TASK_H__
#include "Task.h"
#include "util.h"
#include "ImPduBase.h"

/* CImPdu是一个封装 PduHeader_t 和 m_buf 的PDU报文协议对象.
 *
 * CImPdu:
 * Im  - Instant Message 即时通讯软件,
 * Pdu - Protocol Data Unit 协议数据单元,通俗的说就是一个包单位.
 * 该数据结构分为包头和包体两部分.对象CImPdu的两个成员变量.
 *
 * 包头:
 * typedef struct {
 *     uint32_t length;    // the whole pdu length
 *     uint16_t version;   // pdu version number
 *     uint16_t	flag;      // not used
 *     uint16_t	service_id;//
 *     uint16_t	command_id;// 通过包头的command_id知道该包是什么数据.
 *     uint16_t	seq_num;   // 包序号
 *     uint16_t reversed;  // 保留
 * } PduHeader_t;
 *
 * 包体:
 * CSimpleBuffer  m_buf;
 */

typedef void (*pdu_handler_t)(CImPdu* pPdu, uint32_t conn_uuid);

/* CProxyTask 是一个任务对象,是所有业务逻辑的执行入口 */
class CProxyTask:public CTask
{
public:
  CProxyTask(uint32_t conn_uuid, pdu_handler_t pdu_handler, CImPdu* pPdu);
  virtual ~CProxyTask();

  virtual void run();
private:
  uint32_t      m_conn_uuid;   // 通过uuid获得对应数据包的连接对象.
  pdu_handler_t m_pdu_handler; // pdu_handler_t 是函数指针.
  CImPdu*       m_pPdu;        // m_pPdu 是一个数据包(包括 包头 和 包体).
};

#endif

/* db_proxy_server - ProxyTask.cpp */
#include "ProxyTask.h"
#include "ProxyConn.h"

CProxyTask::CProxyTask(uint32_t conn_uuid, pdu_handler_t pdu_handler, CImPdu* pPdu)
{
  m_conn_uuid = conn_uuid;
  m_pdu_handler = pdu_handler;
  m_pPdu = pPdu;
}

CProxyTask::~CProxyTask()
{
  if (m_pPdu) {
    delete m_pPdu;
  }
}

/* uuid获得对应数据包的连接对象,
 * m_pdu_handler对应业务逻辑的处理函数,
 * run 执行任务,所有的业务逻辑都是由 m_pdu_handler 开始执行 */
void CProxyTask::run()
{
  if (!m_pPdu) {
    // tell CProxyConn to close connection with m_conn_uuid
    CProxyConn::AddResponsePdu(m_conn_uuid, NULL);
  } else {
    if (m_pdu_handler) {
      m_pdu_handler(m_pPdu, m_conn_uuid);
    }
  }
}

/* db_proxy_server - ProxyConn.h */
#ifndef PROXYCONN_H_
#define PROXYCONN_H_

#include <curl/curl.h>
#include "../base/util.h"
#include "imconn.h"

/* uuid获得对应数据包的连接对象. ResponsePdu_t 是应答包 */
typedef struct {
  uint32_t conn_uuid;
  CImPdu*  pPdu;
} ResponsePdu_t;

/* CProxyConn 是代理连接对象. 使用PDU协议处理请求和发送应答消息. */
class CProxyConn : public CImConn {
public:
  CProxyConn();
  virtual ~CProxyConn();

  virtual void Close();

  virtual void OnConnect(net_handle_t handle);
  virtual void OnRead();
  virtual void OnClose();
  virtual void OnTimer(uint64_t curr_tick);

  void HandlePduBuf(uchar_t* pdu_buf, uint32_t pdu_len);

  static void AddResponsePdu(uint32_t conn_uuid, CImPdu* pPdu);	// 工作线程调用
  static void SendResponsePduList(); // 主线程调用
private:
  //由于处理请求和发送回复在两个线程,socket的handle可能重用,
  //所以需要用一个一直增加的uuid来表示一个连接.
  static uint32_t	s_uuid_alloctor;
  uint32_t        m_uuid;

  static CLock s_list_lock;
  static list<ResponsePdu_t*>	s_response_pdu_list; // 主线程发送回复消息
};

int init_proxy_conn(uint32_t thread_num);
CProxyConn* get_proxy_conn_by_uuid(uint32_t uuid);

#endif /* PROXYCONN_H_ */

/* db_proxy_server - ProxyConn.cpp */
#include "ProxyConn.h"
#include "ProxyTask.h"
#include "HandlerMap.h"
#include "atomic.h"
#include "IM.Other.pb.h"
#include "IM.BaseDefine.pb.h"
#include "IM.Server.pb.h"
#include "ThreadPool.h"
#include "SyncCenter.h"

/* typedef hash_map<net_handle_t, CImConn*> ConnMap_t;
 * typedef hash_map<uint32_t, CImConn*> UserMap_t;
 * CHandlerMap 是封装了typedef map<uint32_t, pdu_handler_t> HandlerMap_t;成员变量的类对象.
 * pdu_handler_t 是函数指针 - typedef void (*pdu_handler_t)(CImPdu* pPdu, uint32_t conn_uuid);
 */
static ConnMap_t g_proxy_conn_map; // 其他服务器与db_proxy_server服务器的连接map.
static UserMap_t g_uuid_conn_map;  // 工作线程连接标识uuid与连接CImConn的map.
static CHandlerMap* s_handler_map; // commandId指令标识与pPdu函数指针map.

uint32_t CProxyConn::s_uuid_alloctor = 0;
CLock CProxyConn::s_list_lock;
list<ResponsePdu_t*> CProxyConn::s_response_pdu_list; // 代理服务器回复的应答消息队列.
static CThreadPool g_thread_pool;

/* OnTimer() 是向连接db_proxy_server代理服务器的其他服务器发送心跳.
 * proxy_timer_callback() 作用是向所有连接db_proxy_server的其他服务器发送心跳.
 */
void proxy_timer_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam)
{
  uint64_t cur_time = get_tick_count();
  for (ConnMap_t::iterator it = g_proxy_conn_map.begin(); it != g_proxy_conn_map.end();)
  {
    ConnMap_t::iterator it_old = it;
    it++;

    CProxyConn* pConn = (CProxyConn*)it_old->second;
    pConn->OnTimer(cur_time);
  }
}

/* SendResponsePduList() 是根据应答消息队列连接的不同标识,分别发送消息应答.
 * proxy_loop_callback() 将会被加入到EventLoop中被当做其他任务队列被检测执行.
 */
void proxy_loop_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam)
{
  CProxyConn::SendResponsePduList();
}

/*
 * 用于优雅的关闭连接：
 * 服务器收到SIGTERM信号后,发送CImPduStopReceivePacket数据包给每个连接,
 * 通知消息服务器不要往自己发送数据包请求,
 * 然后注册4s后调用的回调函数,回调时再退出进程
 */
void exit_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam)
{
  log("exit_callback...");
  exit(0);
}

/* sig_handler() 组织cPdu报文发给每个连接,
 * netlib_register_timer() 注册定时器任务, 在eventloop循环中会被检测执行.
 */
static void sig_handler(int sig_no)
{
  if (sig_no == SIGTERM) {
    log("receive SIGTERM, prepare for exit");
    CImPdu cPdu;
    IM::Server::IMStopReceivePacket msg;
    msg.set_result(0);
    cPdu.SetPBMsg(&msg);
    cPdu.SetServiceId(IM::BaseDefine::SID_OTHER);
    cPdu.SetCommandId(IM::BaseDefine::CID_OTHER_STOP_RECV_PACKET);
    for (ConnMap_t::iterator it = g_proxy_conn_map.begin(); it != g_proxy_conn_map.end(); it++) {
      CProxyConn* pConn = (CProxyConn*)it->second;
      pConn->SendPdu(&cPdu);
    }
    // Add By ZhangYuanhao
    // Before stop we need to stop the sync thread,otherwise maybe will not sync the internal data any more
    CSyncCenter::getInstance()->stopSync();

    // callback after 4 second to exit process;
    netlib_register_timer(exit_callback, NULL, 4000);
  }
}

/* CHandlerMap::getInstance() 初始化所有命令标识与cPdu处理函数.
 * g_thread_pool.Init(thread_num); 初始化线程池.
 * proxy_loop_callback 回调函数,是根据应答消息队列连接的不同标识,分别发送消息应答.
 * signal(SIGTERM, sig_handler); 处理终止信号.
 * proxy_timer_callback 回调函数,发送心跳包到连接db_proxy_server的其他服务器
 */
int init_proxy_conn(uint32_t thread_num)
{
  s_handler_map = CHandlerMap::getInstance();
  g_thread_pool.Init(thread_num);

  netlib_add_loop(proxy_loop_callback, NULL);

  signal(SIGTERM, sig_handler);

  return netlib_register_timer(proxy_timer_callback, NULL, 1000);
}

CProxyConn* get_proxy_conn_by_uuid(uint32_t uuid)
{
  CProxyConn* pConn = NULL;
  UserMap_t::iterator it = g_uuid_conn_map.find(uuid);
  if (it != g_uuid_conn_map.end()) {
    pConn = (CProxyConn *)it->second;
  }

  return pConn;
}

//////////////////////////
/* m_uuid 是为了区分不同的工作线程 */
CProxyConn::CProxyConn()
{
  m_uuid = ++CProxyConn::s_uuid_alloctor;
  if (m_uuid == 0) {
    m_uuid = ++CProxyConn::s_uuid_alloctor;
  }

  g_uuid_conn_map.insert(make_pair(m_uuid, this));
}

CProxyConn::~CProxyConn()
{

}

void CProxyConn::Close()
{
  if (m_handle != NETLIB_INVALID_HANDLE) {
    netlib_close(m_handle);
    g_proxy_conn_map.erase(m_handle);

    g_uuid_conn_map.erase(m_uuid);
  }

  ReleaseRef();
}

/* 将其他服务器与db_proxy_server的连接保存在g_proxy_conn_map中,
 * netlib_option 设置连接套接字handle的属性. 
 */
void CProxyConn::OnConnect(net_handle_t handle)
{
  m_handle = handle;

  g_proxy_conn_map.insert(make_pair(handle, this));

  netlib_option(handle, NETLIB_OPT_SET_CALLBACK, (void*)imconn_callback);
  netlib_option(handle, NETLIB_OPT_SET_CALLBACK_DATA, (void*)&g_proxy_conn_map);
  netlib_option(handle, NETLIB_OPT_GET_REMOTE_IP, (void*)&m_peer_ip);
  netlib_option(handle, NETLIB_OPT_GET_REMOTE_PORT, (void*)&m_peer_port);

  log("connect from %s:%d, handle=%d", m_peer_ip.c_str(), m_peer_port, m_handle);
}

// 由于数据包是在另一个线程处理的,所以不能在主线程delete数据包,所以需要Override这个方法
/* 读取消息所有缓存中的数据,HandlePduBuf是处理所有的消息.
 * HandlePduBuf读取一条pdu报文, 根据pdu中的commandId命令标识, 取得对应的pdu报文中的处理函数,
 * 将处理函数组成task任务加入到线程池中待处理.
 */
void CProxyConn::OnRead()
{
  for (;;) {
    uint32_t free_buf_len = m_in_buf.GetAllocSize() - m_in_buf.GetWriteOffset();
    if (free_buf_len < READ_BUF_SIZE)
      m_in_buf.Extend(READ_BUF_SIZE);

    int ret = netlib_recv(m_handle, m_in_buf.GetBuffer() + m_in_buf.GetWriteOffset(), READ_BUF_SIZE);
    if (ret <= 0)
      break;

    m_recv_bytes += ret;
    m_in_buf.IncWriteOffset(ret);
    m_last_recv_tick = get_tick_count();
  }

  uint32_t pdu_len = 0;
  try {
    while ( CImPdu::IsPduAvailable(m_in_buf.GetBuffer(), m_in_buf.GetWriteOffset(), pdu_len) ) {
      HandlePduBuf(m_in_buf.GetBuffer(), pdu_len);
      m_in_buf.Read(NULL, pdu_len);
    }
  } catch (CPduException& ex) {
    log("!!!catch exception, err_code=%u, err_msg=%s, close the connection ",
        ex.GetErrorCode(), ex.GetErrorMsg());
    OnClose();
  }

}


void CProxyConn::OnClose()
{
  Close();
}

/* 发送心跳包cPdu */
void CProxyConn::OnTimer(uint64_t curr_tick)
{
  if (curr_tick > m_last_send_tick + SERVER_HEARTBEAT_INTERVAL) {

    CImPdu cPdu;
    IM::Other::IMHeartBeat msg;
    cPdu.SetPBMsg(&msg);
    cPdu.SetServiceId(IM::BaseDefine::SID_OTHER);
    cPdu.SetCommandId(IM::BaseDefine::CID_OTHER_HEARTBEAT);
    SendPdu(&cPdu);
  }

  if (curr_tick > m_last_recv_tick + SERVER_TIMEOUT) {
    log("proxy connection timeout %s:%d", m_peer_ip.c_str(), m_peer_port);
    Close();
  }
}

/* HandlePduBuf读取一条pdu报文, 根据pdu中的commandId命令标识, 取得对应的pdu报文中的处理函数,
 * 将处理函数组成task任务加入到线程池中待处理.
 */
void CProxyConn::HandlePduBuf(uchar_t* pdu_buf, uint32_t pdu_len)
{
  CImPdu* pPdu = NULL;
  pPdu = CImPdu::ReadPdu(pdu_buf, pdu_len);
  if (pPdu->GetCommandId() == IM::BaseDefine::CID_OTHER_HEARTBEAT) {
    return;
  }

  pdu_handler_t handler = s_handler_map->GetHandler(pPdu->GetCommandId());

  if (handler) {
    CTask* pTask = new CProxyTask(m_uuid, handler, pPdu);
    g_thread_pool.AddTask(pTask);
  } else {
    log("no handler for packet type: %d", pPdu->GetCommandId());
  }
}

/*
 * static method
 * add response pPdu to send list for another thread to send
 * if pPdu == NULL, it means you want to close connection with conn_uuid
 * e.g. parse packet failed
 */
/* 加入应答报文 */
void CProxyConn::AddResponsePdu(uint32_t conn_uuid, CImPdu* pPdu)
{
  ResponsePdu_t* pResp = new ResponsePdu_t;
  pResp->conn_uuid = conn_uuid;
  pResp->pPdu = pPdu;

  s_list_lock.lock();
  s_response_pdu_list.push_back(pResp);
  s_list_lock.unlock();
}

/* 将所有s_response_pdu_list队列中的报文数据一条一条的发出去(即发送应答报文)
 * 报文中的uuid字段可以确定发送的连接pConn, 用该pConn发送应答报文.
 */
void CProxyConn::SendResponsePduList()
{
  s_list_lock.lock();
  while (!s_response_pdu_list.empty()) {
    ResponsePdu_t* pResp = s_response_pdu_list.front();
    s_response_pdu_list.pop_front();
    s_list_lock.unlock();

    CProxyConn* pConn = get_proxy_conn_by_uuid(pResp->conn_uuid);
    if (pConn) {
      if (pResp->pPdu) {
        pConn->SendPdu(pResp->pPdu);
      } else {
        log("close connection uuid=%d by parse pdu error\b", pResp->conn_uuid);
        pConn->Close();
      }
    }

    if (pResp->pPdu)
      delete pResp->pPdu;
    delete pResp;

    s_list_lock.lock();
  }

  s_list_lock.unlock();
}

/* db_proxy_server - SyncCenter.h */
#ifndef __CACHEMANAGER_H__
#define __CACHEMANAGER_H__

#include <list>
#include <map>
#include "ostype.h"
#include "Lock.h"
#include "Condition.h"
#include "ImPduBase.h"
#include "public_define.h"
#include "IM.BaseDefine.pb.h"

class CSyncCenter
{
public:
  static CSyncCenter* getInstance();

  uint32_t getLastUpdate() {
    CAutoLock auto_lock(&last_update_lock_);
    return m_nLastUpdate;
  }
  uint32_t getLastUpdateGroup() {
    CAutoLock auto_lock(&last_update_lock_);
    return m_nLastUpdateGroup;
  }
  string getDeptName(uint32_t nDeptId);
  void startSync();
  void stopSync();
  void init();
  void updateTotalUpdate(uint32_t nUpdated);

private:
  void updateLastUpdateGroup(uint32_t nUpdated);

  CSyncCenter();
  ~CSyncCenter();
  static void* doSyncGroupChat(void* arg);

private:
  void getDept(uint32_t nDeptId, DBDeptInfo_t** pDept);
  DBDeptMap_t* m_pDeptInfo;

  static CSyncCenter* m_pInstance;
  uint32_t m_nLastUpdateGroup;
  uint32_t m_nLastUpdate;

  CCondition* m_pCondGroupChat;
  CLock*      m_pLockGroupChat;
  static bool m_bSyncGroupChatRuning;
  bool m_bSyncGroupChatWaitting;
#ifdef _WIN32
  DWORD m_nGroupChatThreadId;
#else
  pthread_t	m_nGroupChatThreadId;
#endif
  CLock last_update_lock_;
};

#endif /*defined(__CACHEMANAGER_H__) */

/* db_proxy_server - SyncCenter.cpp */
#include <stdlib.h>
#include <sys/signal.h>
#include "SyncCenter.h"
#include "Lock.h"
#include "HttpClient.h"
#include "json/json.h"
#include "DBPool.h"
#include "CachePool.h"
#include "business/Common.h"
#include "business/UserModel.h"
#include "business/GroupModel.h"
#include "business/SessionModel.h"

static CLock* g_pLock = new CLock();
static CRWLock *g_pRWDeptLock = new CRWLock();

CSyncCenter* CSyncCenter::m_pInstance = NULL;
bool CSyncCenter::m_bSyncGroupChatRuning = false;
/**
 *  单例
 *
 *  @return 返回CSyncCenter的单例指针
 */
CSyncCenter* CSyncCenter::getInstance()
{
  CAutoLock autoLock(g_pLock);
  if(m_pInstance == NULL)
  {
    m_pInstance = new CSyncCenter();
  }
  return m_pInstance;
}

/**
 *  构造函数
 */
CSyncCenter::CSyncCenter()
  :m_nGroupChatThreadId(0),
  m_nLastUpdateGroup(time(NULL)),
  m_bSyncGroupChatWaitting(true),
  m_pLockGroupChat(new CLock())
   //m_pLock(new CLock())
{
  m_pCondGroupChat = new CCondition(m_pLockGroupChat);
}

/**
 *  析构函数
 */
CSyncCenter::~CSyncCenter()
{
  if(m_pLockGroupChat != NULL)
  {
    delete m_pLockGroupChat;
  }
  if(m_pCondGroupChat != NULL)
  {
    delete m_pCondGroupChat;
  }
}

/* 获取部门信息 */
void CSyncCenter::getDept(uint32_t nDeptId, DBDeptInfo_t** pDept)
{
  auto it = m_pDeptInfo->find(nDeptId);
  if (it != m_pDeptInfo->end()) {
    *pDept = it->second;
  }
}

/* 获取部门名字 */
string CSyncCenter::getDeptName(uint32_t nDeptId)
{
  CAutoRWLock autoLock(g_pRWDeptLock);
  string strDeptName;
  DBDeptInfo_t* pDept = NULL;;
  getDept(nDeptId, &pDept);
  if (pDept != NULL) {
    strDeptName =  pDept->strName;
  }
  return strDeptName;
}
/**
 *  开启内网数据同步以及群组聊天记录同步
 */
void CSyncCenter::startSync()
{
#ifdef _WIN32
  (void)CreateThread(NULL, 0, doSyncGroupChat, NULL, 0, &m_nGroupChatThreadId);
#else
  (void)pthread_create(&m_nGroupChatThreadId, NULL, doSyncGroupChat, NULL);
#endif
}

/**
 *  停止同步，为了"优雅"的同步，使用了条件变量
 */
void CSyncCenter::stopSync()
{
  m_bSyncGroupChatWaitting = false;
  m_pCondGroupChat->notify();
  while (m_bSyncGroupChatRuning ) {
    usleep(500);
  }
}

/*
 * 初始化函数，从cache里面加载上次同步的时间信息等
 */
void CSyncCenter::init()
{
  // Load total update time
  CacheManager* pCacheManager = CacheManager::getInstance();
  // increase message count
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
  if (pCacheConn)
  {
    string strTotalUpdate = pCacheConn->get("total_user_updated");

    string strLastUpdateGroup = pCacheConn->get("last_update_group");
    pCacheManager->RelCacheConn(pCacheConn);
    if(strTotalUpdate != "")
    {
      m_nLastUpdate = string2int(strTotalUpdate);
    }
    else
    {
      updateTotalUpdate(time(NULL));
    }
    if(strLastUpdateGroup.empty())
    {
      m_nLastUpdateGroup = string2int(strLastUpdateGroup);
    }
    else
    {
      updateLastUpdateGroup(time(NULL));
    }
  }
  else
  {
    log("no cache connection to get total_user_updated");
  }
}
/**
 *  更新上次同步内网信息时间
 *
 *  @param nUpdated 时间
 */

void CSyncCenter::updateTotalUpdate(uint32_t nUpdated)
{
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
  if (pCacheConn) {
    last_update_lock_.lock();
    m_nLastUpdate = nUpdated;
    last_update_lock_.unlock();
    string strUpdated = int2string(nUpdated);
    pCacheConn->set("total_user_update", strUpdated);
    pCacheManager->RelCacheConn(pCacheConn);
  }
  else
  {
    log("no cache connection to get total_user_updated");
  }
}

/**
 *  更新上次同步群组信息时间
 *
 *  @param nUpdated 时间
 */
void CSyncCenter::updateLastUpdateGroup(uint32_t nUpdated)
{
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
  if (pCacheConn) {
    last_update_lock_.lock();
    m_nLastUpdateGroup = nUpdated;
    string strUpdated = int2string(nUpdated);
    last_update_lock_.unlock();

    pCacheConn->set("last_update_group", strUpdated);
    pCacheManager->RelCacheConn(pCacheConn);
  }
  else
  {
    log("no cache connection to get total_user_updated");
  }
}

/**
 *  同步群组聊天信息
 *
 *  @param arg NULL
 *
 *  @return NULL
 */
/* do ...while 一直在循环 - 除非函数stopSync()被调用,发送信号改变了循环结束状态 */
void* CSyncCenter::doSyncGroupChat(void* arg)
{
  m_bSyncGroupChatRuning = true;
  CDBManager* pDBManager = CDBManager::getInstance();
  map<uint32_t, uint32_t> mapChangedGroup;
  do {
    mapChangedGroup.clear();
    CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
    if(pDBConn)
    {
      string strSql = "select id, lastChated from IMGroup where status=0 and lastChated >=" + int2string(m_pInstance->getLastUpdateGroup());
      CResultSet* pResult = pDBConn->ExecuteQuery(strSql.c_str());
      if(pResult)
      {
        while (pResult->Next()) {
          uint32_t nGroupId = pResult->GetInt("id");
          uint32_t nLastChat = pResult->GetInt("lastChated");
          if(nLastChat != 0)
          {
            mapChangedGroup[nGroupId] = nLastChat;
          }
        }
        delete pResult;
      }
      pDBManager->RelDBConn(pDBConn);
    }
    else
    {
      log("no db connection for teamtalk_slave");
    }
    m_pInstance->updateLastUpdateGroup(time(NULL));
    for (auto it=mapChangedGroup.begin(); it!=mapChangedGroup.end(); ++it)
    {
      uint32_t nGroupId =it->first;
      list<uint32_t> lsUsers;
      uint32_t nUpdate = it->second;
      CGroupModel::getInstance()->getGroupUser(nGroupId, lsUsers);
      for (auto it1=lsUsers.begin(); it1!=lsUsers.end(); ++it1)
      {
        uint32_t nUserId = *it1;
        uint32_t nSessionId = INVALID_VALUE;
        nSessionId = CSessionModel::getInstance()->getSessionId(nUserId, nGroupId, IM::BaseDefine::SESSION_TYPE_GROUP, true);
        if(nSessionId != INVALID_VALUE)
        {
          CSessionModel::getInstance()->updateSession(nSessionId, nUpdate);
        }
        else
        {
          CSessionModel::getInstance()->addSession(nUserId, nGroupId, IM::BaseDefine::SESSION_TYPE_GROUP);
        }
      }
    }
    // while (!m_pInstance->m_pCondSync->waitTime(5*1000));
  } while (m_pInstance->m_bSyncGroupChatWaitting && !(m_pInstance->m_pCondGroupChat->waitTime(5*1000)));
  // while(m_pInstance->m_bSyncGroupChatWaitting);
  m_bSyncGroupChatRuning = false;
  return NULL;
}


/* db_proxy_server - db_proxy_server.cpp */
#include "netlib.h"
#include "ConfigFileReader.h"
#include "version.h"
#include "ThreadPool.h"
#include "DBPool.h"
#include "CachePool.h"
#include "ProxyConn.h"
#include "HttpClient.h"
#include "EncDec.h"
#include "business/AudioModel.h"
#include "business/MessageModel.h"
#include "business/SessionModel.h"
#include "business/RelationModel.h"
#include "business/UserModel.h"
#include "business/GroupModel.h"
#include "business/GroupMessageModel.h"
#include "business/FileModel.h"
#include "SyncCenter.h"

string strAudioEnc;
// this callback will be replaced by imconn_callback() in OnConnect()
/* 在函数CProxyConn::OnConnect()中netlib_option会设置该CBaseSocket对象的回调函数为imconn_callback,
 * 即连接套接字可读时,在CBaseSocket::OnRead()内的回调函数调用的是imconn.cpp:imconn_callback()方法.
 */
void proxy_serv_callback(void* callback_data, uint8_t msg, uint32_t handle, void* pParam)
{
  if (msg == NETLIB_MSG_CONNECT)
  {
    CProxyConn* pConn = new CProxyConn();
    pConn->OnConnect(handle);
  }
  else
  {
    log("!!!error msg: %d", msg);
  }
}

int main(int argc, char* argv[])
{
  if ((argc == 2) && (strcmp(argv[1], "-v") == 0)) {
    printf("Server Version: DBProxyServer/%s\n", VERSION);
    printf("Server Build: %s %s\n", __DATE__, __TIME__);
    return 0;
  }

  signal(SIGPIPE, SIG_IGN);
  srand(time(NULL));

  CacheManager* pCacheManager = CacheManager::getInstance();
  if (!pCacheManager) {
    log("CacheManager init failed");
    return -1;
  }

  CDBManager* pDBManager = CDBManager::getInstance();
  if (!pDBManager) {
    log("DBManager init failed");
    return -1;
  }
  puts("db init success");
  // 主线程初始化单例，不然在工作线程可能会出现多次初始化
  if (!CAudioModel::getInstance()) {
    return -1;
  }

  if (!CGroupMessageModel::getInstance()) {
    return -1;
  }

  if (!CGroupModel::getInstance()) {
    return -1;
  }

  if (!CMessageModel::getInstance()) {
    return -1;
  }

  if (!CSessionModel::getInstance()) {
    return -1;
  }

  if(!CRelationModel::getInstance())
  {
    return -1;
  }

  if (!CUserModel::getInstance()) {
    return -1;
  }

  if (!CFileModel::getInstance()) {
    return -1;
  }


  CConfigFileReader config_file("dbproxyserver.conf");

  char* listen_ip = config_file.GetConfigName("ListenIP");
  char* str_listen_port = config_file.GetConfigName("ListenPort");
  char* str_thread_num = config_file.GetConfigName("ThreadNum");
  char* str_file_site = config_file.GetConfigName("MsfsSite");
  char* str_aes_key = config_file.GetConfigName("aesKey");
  char* unix_socket_path = config_file.GetConfigName("UnixSocket");


  if (!listen_ip || !str_listen_port || !str_thread_num || !str_file_site || !str_aes_key) {
    log("missing ListenIP/ListenPort/ThreadNum/MsfsSite/aesKey, exit...");
    return -1;
  }

  if(strlen(str_aes_key) != 32)
  {
    log("aes key is invalied");
    return -2;
  }
  string strAesKey(str_aes_key, 32);
  CAes cAes = CAes(strAesKey);
  string strAudio = "[语音]";
  char* pAudioEnc;
  uint32_t nOutLen;
  if(cAes.Encrypt(strAudio.c_str(), strAudio.length(), &pAudioEnc, nOutLen) == 0)
  {
    strAudioEnc.clear();
    strAudioEnc.append(pAudioEnc, nOutLen);
    cAes.Free(pAudioEnc);
  }

  uint16_t listen_port = atoi(str_listen_port);
  uint32_t thread_num = atoi(str_thread_num);

  string strFileSite(str_file_site);
  CAudioModel::getInstance()->setUrl(strFileSite);

  int ret = netlib_init();

  if (ret == NETLIB_ERROR)
    return ret;

  /// yunfan add 2014.9.28
  // for 603 push
  curl_global_init(CURL_GLOBAL_ALL);
  /// yunfan add end

  init_proxy_conn(thread_num);
  CSyncCenter::getInstance()->init();
  CSyncCenter::getInstance()->startSync();

  CStrExplode listen_ip_list(listen_ip, ';');
  for (uint32_t i = 0; i < listen_ip_list.GetItemCnt(); i++)
  {
    ret = netlib_listen(listen_ip_list.GetItem(i), listen_port, proxy_serv_callback, NULL);
    if (ret == NETLIB_ERROR)
      return ret;
  }

  if(unix_socket_path)
  {
    netlib_unix_listen(unix_socket_path,proxy_serv_callback,NULL);
  }

  printf("server start listen on: %s:%d\n", listen_ip,  listen_port);
  printf("now enter the event loop...\n");
  writePid();
  netlib_eventloop(10);

  return 0;
}

/* db_proxy_server - business - Login.h */
#ifndef LOGIN_H_
#define LOGIN_H_

#include "ImPduBase.h"

namespace DB_PROXY {
/*  @param pPdu      收到的packet包指针
 *  @param conn_uuid 该包过来的socket 描述符
 */
  void doLogin(CImPdu* pPdu, uint32_t conn_uuid);
};

#endif /* LOGIN_H_ */

/* db_proxy_server - business - Login.cpp */
#include <list>
#include "../ProxyConn.h"
#include "../HttpClient.h"
#include "../SyncCenter.h"
#include "Login.h"
#include "UserModel.h"
#include "TokenValidator.h"
#include "json/json.h"
#include "Common.h"
#include "IM.Server.pb.h"
#include "Base64.h"
#include "InterLogin.h"
#include "ExterLogin.h"

CInterLoginStrategy g_loginStrategy;

hash_map<string, list<uint32_t> > g_hmLimits;
CLock g_cLimitLock;
namespace DB_PROXY {

/*  @param pPdu      收到的packet包指针
 *  @param conn_uuid 该包过来的socket 描述符
 *
 * 用户登录, 检测密码无误则:
 * 取出用户信息, msgResp将被设置为包体,
 * 将登陆应答包pPduResp加入到消息队列,
 * init_proxy_conn()函数将发送响应包给客户端.
 *
 * C数组的序列化和序列化API
 * 反序列化: bool ParseFromArray(const void* data, int size);
 * 序列化  : bool SerializeToArray(void* data, int size) const;
 */
void doLogin(CImPdu* pPdu, uint32_t conn_uuid)
{
  CImPdu* pPduResp = new CImPdu;

  IM::Server::IMValidateReq msg;
  IM::Server::IMValidateRsp msgResp;

  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    string strDomain = msg.user_name();
    string strPass = msg.password();

    msgResp.set_user_name(strDomain);
    msgResp.set_attach_data(msg.attach_data());

    do
    {
      CAutoLock cAutoLock(&g_cLimitLock);
      list<uint32_t>& lsErrorTime = g_hmLimits[strDomain];
      uint32_t tmNow = time(NULL);

      //清理超过30分钟的错误时间点记录
      /*
         清理放在这里还是放在密码错误后添加的时候呢？
         放在这里，每次都要遍历，会有一点点性能的损失。
         放在后面，可能会造成30分钟之前有10次错的，但是本次是对的就没办法再访问了。
       */
      auto itTime=lsErrorTime.begin();
      for(; itTime!=lsErrorTime.end();++itTime)
      {
        if(tmNow - *itTime > 30*60)
        {
          break;
        }
      }
      if(itTime != lsErrorTime.end())
      {
        lsErrorTime.erase(itTime, lsErrorTime.end());
      }

      // 判断30分钟内密码错误次数是否大于10
      if(lsErrorTime.size() > 10)
      {
        itTime = lsErrorTime.begin();
        if(tmNow - *itTime <= 30*60)
        {
          msgResp.set_result_code(6);
          msgResp.set_result_string("用户名/密码错误次数太多");
          pPduResp->SetPBMsg(&msgResp);
          pPduResp->SetSeqNum(pPdu->GetSeqNum());
          pPduResp->SetServiceId(IM::BaseDefine::SID_OTHER);
          pPduResp->SetCommandId(IM::BaseDefine::CID_OTHER_VALIDATE_RSP);
          CProxyConn::AddResponsePdu(conn_uuid, pPduResp);
          return ;
        }
      }
    } while(false);

    log("%s request login.", strDomain.c_str());

    //////////
    IM::BaseDefine::UserInfo cUser;

    if(g_loginStrategy.doLogin(strDomain, strPass, cUser))
    {
      IM::BaseDefine::UserInfo* pUser = msgResp.mutable_user_info();
      pUser->set_user_id(cUser.user_id());
      pUser->set_user_gender(cUser.user_gender());
      pUser->set_department_id(cUser.department_id());
      pUser->set_user_nick_name(cUser.user_nick_name());
      pUser->set_user_domain(cUser.user_domain());
      pUser->set_avatar_url(cUser.avatar_url());

      pUser->set_email(cUser.email());
      pUser->set_user_tel(cUser.user_tel());
      pUser->set_user_real_name(cUser.user_real_name());
      pUser->set_status(0);

      pUser->set_sign_info(cUser.sign_info());

      msgResp.set_result_code(0);
      msgResp.set_result_string("成功");

      //如果登陆成功，则清除错误尝试限制
      CAutoLock cAutoLock(&g_cLimitLock);
      list<uint32_t>& lsErrorTime = g_hmLimits[strDomain];
      lsErrorTime.clear();
    }
    else
    {
      //密码错误，记录一次登陆失败
      uint32_t tmCurrent = time(NULL);
      CAutoLock cAutoLock(&g_cLimitLock);
      list<uint32_t>& lsErrorTime = g_hmLimits[strDomain];
      lsErrorTime.push_front(tmCurrent);

      log("get result false");
      msgResp.set_result_code(1);
      msgResp.set_result_string("用户名/密码错误");
    }
  }
  else
  {
    msgResp.set_result_code(2);
    msgResp.set_result_string("服务端内部错误");
  }

  pPduResp->SetPBMsg(&msgResp); //设置包体数据信息(PB: packet body)
  pPduResp->SetSeqNum(pPdu->GetSeqNum());
  pPduResp->SetServiceId(IM::BaseDefine::SID_OTHER);
  pPduResp->SetCommandId(IM::BaseDefine::CID_OTHER_VALIDATE_RSP);
  CProxyConn::AddResponsePdu(conn_uuid, pPduResp);
}

};

/* db_proxy_server - business - LoginStrategy.h */
#ifndef __LOGINSTRATEGY_H__
#define __LOGINSTRATEGY_H__

#include <iostream>

#include "IM.BaseDefine.pb.h"

class CLoginStrategy
{
public:
  virtual bool doLogin(const std::string& strName, const std::string& strPass, IM::BaseDefine::UserInfo& user) = 0;
};

#endif /*defined(__LOGINSTRATEGY_H__) */

/* db_proxy_server - business - InterLogin.h */
#ifndef __INTERLOGIN_H__
#define __INTERLOGIN_H__
#include "LoginStrategy.h"

/* 内部数据库验证策略 */
class CInterLoginStrategy :public CLoginStrategy
{
public:
  virtual bool doLogin(const std::string& strName, const std::string& strPass, IM::BaseDefine::UserInfo& user);
};

#endif /*defined(__INTERLOGIN_H__) */

/* db_proxy_server - business - InterLogin.cpp */
#include "InterLogin.h"
#include "../DBPool.h"
#include "EncDec.h"

/* 内部数据库验证策略.
 * 查询数据库中用户信息(没有使用MySQL预处理语句查询数据库).核查用户密码.
 */
bool CInterLoginStrategy::doLogin(const std::string &strName, const std::string &strPass, IM::BaseDefine::UserInfo& user)
{
  bool bRet = false;
  CDBManager* pDBManger = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManger->GetDBConn("teamtalk_slave");
  if (pDBConn) {

    string tmpName(pDBConn->EscapeString(strName.c_str(),strName.size()));

    string strSql = "select * from IMUser where name='" + tmpName + "' and status=0";
    //string strSql = "select * from IMUser where name=? and status=?";
    /*
       CPrepareStatement* stmt = new CPrepareStatement();
       if (stmt->Init(pDBConn->GetMysql(), strSql))
       {
       uint32_t nStatus = 0;
       uint32_t index = 0;
       stmt->SetParam(index++, strName);
       stmt->SetParam(index++, nStatus);
       CResultSet* pResultSet = stmt->ExecuteQuery();
     */

    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if(pResultSet)
    {
      string strResult, strSalt;
      uint32_t nId, nGender, nDeptId, nStatus;
      string strNick, strAvatar, strEmail, strRealName, strTel, strDomain,strSignInfo;
      while (pResultSet->Next()) {
        nId = pResultSet->GetInt("id");
        strResult = pResultSet->GetString("password");
        strSalt = pResultSet->GetString("salt");

        strNick = pResultSet->GetString("nick");
        nGender = pResultSet->GetInt("sex");
        strRealName = pResultSet->GetString("name");
        strDomain = pResultSet->GetString("domain");
        strTel = pResultSet->GetString("phone");
        strEmail = pResultSet->GetString("email");
        strAvatar = pResultSet->GetString("avatar");
        nDeptId = pResultSet->GetInt("departId");
        nStatus = pResultSet->GetInt("status");
        strSignInfo = pResultSet->GetString("sign_info");

      }

      string strInPass = strPass + strSalt;
      char szMd5[33];
      CMd5::MD5_Calculate(strInPass.c_str(), strInPass.length(), szMd5);
      string strOutPass(szMd5);
      if(strOutPass == strResult)
      {
        bRet = true;
        user.set_user_id(nId);
        user.set_user_nick_name(strNick);
        user.set_user_gender(nGender);
        user.set_user_real_name(strRealName);
        user.set_user_domain(strDomain);
        user.set_user_tel(strTel);
        user.set_email(strEmail);
        user.set_avatar_url(strAvatar);
        user.set_department_id(nDeptId);
        user.set_status(nStatus);
        user.set_sign_info(strSignInfo);

      }
      delete  pResultSet;

    }
    // }
    // delete stmt;
    pDBManger->RelDBConn(pDBConn);
  }
  return bRet;
}

/* db_proxy_server - business - ExterLogin.h */
#ifndef __EXTERLOGIN_H__
#define __EXTERLOGIN_H__
#include "LoginStrategy.h"

class CExterLoginStrategy:public CLoginStrategy
{
public:
    virtual bool doLogin(const std::string& strName, const std::string& strPass, IM::BaseDefine::UserInfo& user);
};
#endif /*defined(__EXTERLOGIN_H__) */

/* db_proxy_server - business - ExterLogin.cpp */
#include "ExterLogin.h"

/* 需要通过外部接口进行验证 (暂时没有实现) */
const std::string strLoginUrl = "http://xxxx";
bool CExterLoginStrategy::doLogin(const std::string &strName, const std::string &strPass, IM::BaseDefine::UserInfo& user)
{
    bool bRet = false;
    return bRet;
}

/* db_proxy_server - business - AudioModel.h */
#ifndef AUDIO_MODEL_H_
#define AUDIO_MODEL_H_

#include <list>
#include <map>
#include "public_define.h"
#include "util.h"
#include "IM.BaseDefine.pb.h"

using namespace std;

/* setUrl 设置语音存储的url地址
 * readAudios 读取语音消息
 * saveAudioInfo 存储语音消息
 * readAudioContent 读取语音的具体内容
 */
class CAudioModel {
public:
  virtual ~CAudioModel();
  static CAudioModel* getInstance();

  void setUrl(string& strFileUrl);
  bool readAudios(list<IM::BaseDefine::MsgInfo>& lsMsg);
  int saveAudioInfo(uint32_t nFromId, uint32_t nToId, uint32_t nCreateTime, const char* pAudioData, uint32_t nAudioLen);

private:
  CAudioModel();
  //void GetAudiosInfo(uint32_t nAudioId, IM::BaseDefine::MsgInfo& msg);
  bool readAudioContent(uint32_t nCostTime, uint32_t nSize, const string& strPath, IM::BaseDefine::MsgInfo& msg);

private:
  static CAudioModel*	m_pInstance;
  string m_strFileSite;
};

#endif /* AUDIO_MODEL_H_ */

/* db_proxy_server - business - AudioModel.cpp */
#include "../DBPool.h"
#include "../HttpClient.h"
#include "AudioModel.h"

using namespace std;

//AudioModel
CAudioModel* CAudioModel::m_pInstance = NULL;

/**
 *  构造函数
 */
CAudioModel::CAudioModel()
{

}

/**
 *  析构函数
 */
CAudioModel::~CAudioModel()
{

}

/**
 *  单例
 *
 *  @return 单例的指针
 */
CAudioModel* CAudioModel::getInstance()
{
  if (!m_pInstance) {
    m_pInstance = new CAudioModel();
  }

  return m_pInstance;
}

/**
 *  设置语音存储的url地址
 *
 *  @param strFileSite 上传的url
 */
void CAudioModel::setUrl(string& strFileSite)
{
  m_strFileSite = strFileSite;
  if(m_strFileSite[m_strFileSite.length()] != '/')
  {
    m_strFileSite += "/";
  }
}

/**
 *  读取语音消息
 *
 *  @param nAudioId 语音的Id
 *  @param cMsg     语音消息，引用
 *
 *  @return bool 成功返回true，失败返回false
 */
bool CAudioModel::readAudios(list<IM::BaseDefine::MsgInfo>& lsMsg)
{
  if(lsMsg.empty())
  {
    return true;
  }
  bool bRet = false;
  CDBManager* pDBManger = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManger->GetDBConn("teamtalk_slave");
  if (pDBConn)
  {
    for (auto it=lsMsg.begin(); it!=lsMsg.end(); )
    {
      IM::BaseDefine::MsgType nType = it->msg_type();
      if((IM::BaseDefine::MSG_TYPE_GROUP_AUDIO ==  nType) || (IM::BaseDefine::MSG_TYPE_SINGLE_AUDIO == nType))
      {
        string strSql = "select * from IMAudio where id=" + it->msg_data();
        CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
        if (pResultSet)
        {
          while (pResultSet->Next()) {
            uint32_t nCostTime = pResultSet->GetInt("duration");
            uint32_t nSize = pResultSet->GetInt("size");
            string strPath = pResultSet->GetString("path");
            readAudioContent(nCostTime, nSize, strPath, *it);
          }
          ++it;
          delete pResultSet;
        }
        else
        {
          log("no result for sql:%s", strSql.c_str());
          it = lsMsg.erase(it);
        }
      }
      else
      {
        ++it;
      }
    }
    pDBManger->RelDBConn(pDBConn);
    bRet = true;
  }
  else
  {
    log("no connection for teamtalk_slave");
  }
  return bRet;
}

/**
 *  存储语音消息
 *
 *  @param nFromId     发送者Id
 *  @param nToId       接收者Id
 *  @param nCreateTime 发送时间
 *  @param pAudioData  指向语音消息的指针
 *  @param nAudioLen   语音消息的长度
 *
 *  @return 成功返回语音id，失败返回-1
 */
int CAudioModel::saveAudioInfo(uint32_t nFromId, uint32_t nToId, uint32_t nCreateTime, const char* pAudioData, uint32_t nAudioLen)
{
  // parse audio data
  uint32_t nCostTime = CByteStream::ReadUint32((uchar_t*)pAudioData);
  uchar_t* pRealData = (uchar_t*)pAudioData + 4;
  uint32_t nRealLen = nAudioLen - 4;
  int nAudioId = -1;

  CHttpClient httpClient;
  string strPath = httpClient.UploadByteFile(m_strFileSite, pRealData, nRealLen);
  if (!strPath.empty())
  {
    CDBManager* pDBManager = CDBManager::getInstance();
    CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
    if (pDBConn)
    {
      uint32_t nStartPos = 0;
      string strSql = "insert into IMAudio(`fromId`, `toId`, `path`, `size`, `duration`, `created`) values (?, ?, ?, ?, ?, ?)";
      replace_mark(strSql, nFromId, nStartPos);
      replace_mark(strSql, nToId, nStartPos);
      replace_mark(strSql, strPath, nStartPos);
      replace_mark(strSql, nRealLen, nStartPos);
      replace_mark(strSql, nCostTime, nStartPos);
      replace_mark(strSql, nCreateTime, nStartPos);
      if (pDBConn->ExecuteUpdate(strSql.c_str()))
      {
        nAudioId = pDBConn->GetInsertId();
        log("audioId=%d", nAudioId);
      } else
      {
        log("sql failed: %s", strSql.c_str());
      }
      pDBManager->RelDBConn(pDBConn);
    }
    else
    {
      log("no db connection for teamtalk_master");
    }
  }
  else
  {
    log("upload file failed");
  }
  return nAudioId;
}

/**
 *  读取语音的具体内容
 *
 *  @param nCostTime 语音时长
 *  @param nSize     语音大小
 *  @param strPath   语音存储的url
 *  @param cMsg      msg结构体
 *
 *  @return 成功返回true，失败返回false
 */
bool CAudioModel::readAudioContent(uint32_t nCostTime, uint32_t nSize, const string& strPath, IM::BaseDefine::MsgInfo& cMsg)
{
  if (strPath.empty() || nCostTime == 0 || nSize == 0) {
    return false;
  }

  // 分配内存，写入音频时长
  AudioMsgInfo cAudioMsg;
  uchar_t* pData = new uchar_t [4 + nSize];
  cAudioMsg.data = pData;
  CByteStream::WriteUint32(cAudioMsg.data, nCostTime);
  cAudioMsg.data_len = 4;
  cAudioMsg.fileSize = nSize;

  // 获取音频数据，写入上面分配的内存
  CHttpClient httpClient;
  if(!httpClient.DownloadByteFile(strPath, &cAudioMsg))
  {
    delete [] pData;
    return false;
  }

  log("download_path=%s, data_len=%d", strPath.c_str(), cAudioMsg.data_len);
  cMsg.set_msg_data((const char*)cAudioMsg.data, cAudioMsg.data_len);

  delete [] pData;
  return true;
}

/* db_proxy_server - business - UserModel.h */
#ifndef __USERMODEL_H__
#define __USERMODEL_H__

#include "IM.BaseDefine.pb.h"
#include "ImPduBase.h"
#include "public_define.h"

/* getChangedId 获取信息变更的用户id(多个).
 * getUsers 根据用户id(多个),获取用户信息表.
 * getUser 根据用户id(单个),获取用户信息.
 * updateUser 更新用户信息.
 * insertUser 插入一条用户数据.
 * clearUserCounter 清空用户记录.
 * setCallReport 插入一条用户调用记录.
 * updateUserSignInfo 更新用户个人签名.
 * getUserSingInfo 获取用户个人签名.
 * updatePushShield 设置APP应用夜间消息推送屏蔽.
 * getPushShield 获取APP应用夜间消息推送屏蔽状态.
 */
class CUserModel
{
public:
  static CUserModel* getInstance();
  ~CUserModel();
  void getChangedId(uint32_t& nLastTime, list<uint32_t>& lsIds);
  void getUsers(list<uint32_t> lsIds, list<IM::BaseDefine::UserInfo>& lsUsers);
  bool getUser(uint32_t nUserId, DBUserInfo_t& cUser);

  bool updateUser(DBUserInfo_t& cUser);
  bool insertUser(DBUserInfo_t& cUser);
//void getUserByNick(const list<string>& lsNicks, list<IM::BaseDefine::UserInfo>& lsUsers);
  void clearUserCounter(uint32_t nUserId, uint32_t nPeerId, IM::BaseDefine::SessionType nSessionType);
  void setCallReport(uint32_t nUserId, uint32_t nPeerId, IM::BaseDefine::ClientType nClientType);

  bool updateUserSignInfo(uint32_t user_id, const string& sign_info);
  bool getUserSingInfo(uint32_t user_id, string* sign_info);
  bool updatePushShield(uint32_t user_id, uint32_t shield_status);
  bool getPushShield(uint32_t user_id, uint32_t* shield_status);

private:
  CUserModel();
private:
  static CUserModel* m_pInstance;
};

#endif /*defined(__USERMODEL_H__) */

/* db_proxy_server - business - UserModel.cpp */
#include "UserModel.h"
#include "../DBPool.h"
#include "../CachePool.h"
#include "Common.h"
#include "SyncCenter.h"

CUserModel* CUserModel::m_pInstance = NULL;

CUserModel::CUserModel()
{
}

CUserModel::~CUserModel()
{
}

CUserModel* CUserModel::getInstance()
{
  if(m_pInstance == NULL)
  {
    m_pInstance = new CUserModel();
  }
  return m_pInstance;
}

/* 获取信息变更的用户id(多个). */
void CUserModel::getChangedId(uint32_t& nLastTime, list<uint32_t> &lsIds)
{
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  if (pDBConn)
  {
    string strSql ;
    if(nLastTime == 0)
    {
      strSql = "select id, updated from IMUser where status != 3";
    }
    else
    {
      strSql = "select id, updated from IMUser where updated>=" + int2string(nLastTime);
    }
    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if(pResultSet)
    {
      while (pResultSet->Next()) {
        uint32_t nId = pResultSet->GetInt("id");
        uint32_t nUpdated = pResultSet->GetInt("updated");
        if(nLastTime < nUpdated)
        {
          nLastTime = nUpdated;
        }
        lsIds.push_back(nId);
      }
      delete pResultSet;
    }
    else
    {
      log(" no result set for sql:%s", strSql.c_str());
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_slave");
  }
}

/* 根据用户id(多个),获取用户信息表. */
void CUserModel::getUsers(list<uint32_t> lsIds, list<IM::BaseDefine::UserInfo> &lsUsers)
{
  if (lsIds.empty()) {
    log("list is empty");
    return;
  }
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  if (pDBConn)
  {
    string strClause;
    bool bFirst = true;
    for (auto it = lsIds.begin(); it!=lsIds.end(); ++it)
    {
      if(bFirst)
      {
        bFirst = false;
        strClause += int2string(*it);
      }
      else
      {
        strClause += ("," + int2string(*it));
      }
    }
    string  strSql = "select * from IMUser where id in (" + strClause + ")";
    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if(pResultSet)
    {
      while (pResultSet->Next())
      {
        IM::BaseDefine::UserInfo cUser;
        cUser.set_user_id(pResultSet->GetInt("id"));
        cUser.set_user_gender(pResultSet->GetInt("sex"));
        cUser.set_user_nick_name(pResultSet->GetString("nick"));
        cUser.set_user_domain(pResultSet->GetString("domain"));
        cUser.set_user_real_name(pResultSet->GetString("name"));
        cUser.set_user_tel(pResultSet->GetString("phone"));
        cUser.set_email(pResultSet->GetString("email"));
        cUser.set_avatar_url(pResultSet->GetString("avatar"));
        cUser.set_sign_info(pResultSet->GetString("sign_info"));

        cUser.set_department_id(pResultSet->GetInt("departId"));
        cUser.set_department_id(pResultSet->GetInt("departId"));
        cUser.set_status(pResultSet->GetInt("status"));
        lsUsers.push_back(cUser);
      }
      delete pResultSet;
    }
    else
    {
      log(" no result set for sql:%s", strSql.c_str());
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_slave");
  }
}

/* 根据用户id(单个),获取用户信息. */
bool CUserModel::getUser(uint32_t nUserId, DBUserInfo_t &cUser)
{
  bool bRet = false;
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  if (pDBConn)
  {
    string strSql = "select * from IMUser where id="+int2string(nUserId);
    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if(pResultSet)
    {
      while (pResultSet->Next())
      {
        cUser.nId = pResultSet->GetInt("id");
        cUser.nSex = pResultSet->GetInt("sex");
        cUser.strNick = pResultSet->GetString("nick");
        cUser.strDomain = pResultSet->GetString("domain");
        cUser.strName = pResultSet->GetString("name");
        cUser.strTel = pResultSet->GetString("phone");
        cUser.strEmail = pResultSet->GetString("email");
        cUser.strAvatar = pResultSet->GetString("avatar");
        cUser.sign_info = pResultSet->GetString("sign_info");
        cUser.nDeptId = pResultSet->GetInt("departId");
        cUser.nStatus = pResultSet->GetInt("status");
        bRet = true;
      }
      delete pResultSet;
    }
    else
    {
      log("no result set for sql:%s", strSql.c_str());
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_slave");
  }
  return bRet;
}

/* 更新用户信息. */
bool CUserModel::updateUser(DBUserInfo_t &cUser)
{
  bool bRet = false;
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if (pDBConn)
  {
    uint32_t nNow = (uint32_t)time(NULL);
    string strSql = "update IMUser set `sex`=" + int2string(cUser.nSex)+ ", `nick`='" + cUser.strNick +"', `domain`='"+ cUser.strDomain + "', `name`='" + cUser.strName + "', `phone`='" + cUser.strTel + "', `email`='" + cUser.strEmail+ "', `avatar`='" + cUser.strAvatar + "', `sign_info`='" + cUser.sign_info +"', `departId`='" + int2string(cUser.nDeptId) + "', `status`=" + int2string(cUser.nStatus) + ", `updated`="+int2string(nNow) + " where id="+int2string(cUser.nId);
    bRet = pDBConn->ExecuteUpdate(strSql.c_str());
    if(!bRet)
    {
      log("updateUser: update failed:%s", strSql.c_str());
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
  return bRet;
}

/* 插入一条用户数据. */
bool CUserModel::insertUser(DBUserInfo_t &cUser)
{
  bool bRet = false;
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if (pDBConn)
  {
    string strSql = "insert into IMUser(`id`,`sex`,`nick`,`domain`,`name`,`phone`,`email`,`avatar`,`sign_info`,`departId`,`status`,`created`,`updated`) values(?,?,?,?,?,?,?,?,?,?,?,?)";
    CPrepareStatement* stmt = new CPrepareStatement();
    if (stmt->Init(pDBConn->GetMysql(), strSql))
    {
      uint32_t nNow = (uint32_t) time(NULL);
      uint32_t index = 0;
      uint32_t nGender = cUser.nSex;
      uint32_t nStatus = cUser.nStatus;
      stmt->SetParam(index++, cUser.nId);
      stmt->SetParam(index++, nGender);
      stmt->SetParam(index++, cUser.strNick);
      stmt->SetParam(index++, cUser.strDomain);
      stmt->SetParam(index++, cUser.strName);
      stmt->SetParam(index++, cUser.strTel);
      stmt->SetParam(index++, cUser.strEmail);
      stmt->SetParam(index++, cUser.strAvatar);

      stmt->SetParam(index++, cUser.sign_info);
      stmt->SetParam(index++, cUser.nDeptId);
      stmt->SetParam(index++, nStatus);
      stmt->SetParam(index++, nNow);
      stmt->SetParam(index++, nNow);
      bRet = stmt->ExecuteUpdate();

      if (!bRet)
      {
        log("insert user failed: %s", strSql.c_str());
      }
    }
    delete stmt;
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
  return bRet;
}

/* 根据用户 id 清空用户记录. */
void CUserModel::clearUserCounter(uint32_t nUserId, uint32_t nPeerId, IM::BaseDefine::SessionType nSessionType)
{
  if(IM::BaseDefine::SessionType_IsValid(nSessionType))
  {
    CacheManager* pCacheManager = CacheManager::getInstance();
    CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
    if (pCacheConn)
    {
      // Clear P2P msg Counter
      if(nSessionType == IM::BaseDefine::SESSION_TYPE_SINGLE)
      {
        int nRet = pCacheConn->hdel("unread_" + int2string(nUserId), int2string(nPeerId));
        if(!nRet)
        {
          log("hdel failed %d->%d", nPeerId, nUserId);
        }
      }
      // Clear Group msg Counter
      else if(nSessionType == IM::BaseDefine::SESSION_TYPE_GROUP)
      {
        string strGroupKey = int2string(nPeerId) + GROUP_TOTAL_MSG_COUNTER_REDIS_KEY_SUFFIX;
        map<string, string> mapGroupCount;
        bool bRet = pCacheConn->hgetAll(strGroupKey, mapGroupCount);
        if(bRet)
        {
          string strUserKey = int2string(nUserId) + "_" + int2string(nPeerId) + GROUP_USER_MSG_COUNTER_REDIS_KEY_SUFFIX;
          string strReply = pCacheConn->hmset(strUserKey, mapGroupCount);
          if(strReply.empty()) {
            log("hmset %s failed !", strUserKey.c_str());
          }
        }
        else
        {
          log("hgetall %s failed!", strGroupKey.c_str());
        }

      }
      pCacheManager->RelCacheConn(pCacheConn);
    }
    else
    {
      log("no cache connection for unread");
    }
  }
  else{
    log("invalid sessionType. userId=%u, fromId=%u, sessionType=%u", nUserId, nPeerId, nSessionType);
  }
}

/* 插入一条用户调用记录. */
void CUserModel::setCallReport(uint32_t nUserId, uint32_t nPeerId, IM::BaseDefine::ClientType nClientType)
{
  if(IM::BaseDefine::ClientType_IsValid(nClientType))
  {
    CDBManager* pDBManager = CDBManager::getInstance();
    CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
    if(pDBConn)
    {
      string strSql = "insert into IMCallLog(`userId`, `peerId`, `clientType`,`created`,`updated`) values(?,?,?,?,?)";
      CPrepareStatement* stmt = new CPrepareStatement();
      if (stmt->Init(pDBConn->GetMysql(), strSql))
      {
        uint32_t nNow = (uint32_t) time(NULL);
        uint32_t index = 0;
        uint32_t nClient = (uint32_t) nClientType;
        stmt->SetParam(index++, nUserId);
        stmt->SetParam(index++, nPeerId);
        stmt->SetParam(index++, nClient);
        stmt->SetParam(index++, nNow);
        stmt->SetParam(index++, nNow);
        bool bRet = stmt->ExecuteUpdate();

        if (!bRet)
        {
          log("insert report failed: %s", strSql.c_str());
        }
      }
      delete stmt;
      pDBManager->RelDBConn(pDBConn);
    }
    else
    {
      log("no db connection for teamtalk_master");
    }

  }
  else
  {
    log("invalid clienttype. userId=%u, peerId=%u, clientType=%u", nUserId, nPeerId, nClientType);
  }
}

/* 更新用户个人签名. */
bool CUserModel::updateUserSignInfo(uint32_t user_id, const string& sign_info)
{

  if (sign_info.length() > 128) {
    log("updateUserSignInfo: sign_info.length()>128.\n");
    return false;
  }
  bool rv = false;
  CDBManager* db_manager = CDBManager::getInstance();
  CDBConn* db_conn = db_manager->GetDBConn("teamtalk_master");
  if (db_conn) {
    uint32_t now = (uint32_t)time(NULL);
    string str_sql = "update IMUser set `sign_info`='" + sign_info + "', `updated`=" + int2string(now) + " where id="+int2string(user_id);
    rv = db_conn->ExecuteUpdate(str_sql.c_str());
    if(!rv) {
      log("updateUserSignInfo: update failed:%s", str_sql.c_str());
    }else{
      CSyncCenter::getInstance()->updateTotalUpdate(now);

    }
    db_manager->RelDBConn(db_conn);
  } else {
    log("updateUserSignInfo: no db connection for teamtalk_master");
  }
  return rv;
}

/* 获取用户个人签名. */
bool CUserModel::getUserSingInfo(uint32_t user_id, string* sign_info)
{
  bool rv = false;
  CDBManager* db_manager = CDBManager::getInstance();
  CDBConn* db_conn = db_manager->GetDBConn("teamtalk_slave");
  if (db_conn) {
    string str_sql = "select sign_info from IMUser where id="+int2string(user_id);
    CResultSet* result_set = db_conn->ExecuteQuery(str_sql.c_str());
    if(result_set) {
      if (result_set->Next()) {
        *sign_info = result_set->GetString("sign_info");
        rv = true;
      }
      delete result_set;
    } else {
      log("no result set for sql:%s", str_sql.c_str());
    }
    db_manager->RelDBConn(db_conn);
  } else {
    log("no db connection for teamtalk_slave");
  }
  return rv;
}

/* 设置APP应用夜间消息推送屏蔽. */
bool CUserModel::updatePushShield(uint32_t user_id, uint32_t shield_status)
{
  bool rv = false;

  CDBManager* db_manager = CDBManager::getInstance();
  CDBConn* db_conn = db_manager->GetDBConn("teamtalk_master");
  if (db_conn) {
    uint32_t now = (uint32_t)time(NULL);
    string str_sql = "update IMUser set `push_shield_status`="+ int2string(shield_status) + ", `updated`=" + int2string(now) + " where id="+int2string(user_id);
    rv = db_conn->ExecuteUpdate(str_sql.c_str());
    if(!rv) {
      log("updatePushShield: update failed:%s", str_sql.c_str());
    }
    db_manager->RelDBConn(db_conn);
  } else {
    log("updatePushShield: no db connection for teamtalk_master");
  }

  return rv;
}

/* 获取APP应用夜间消息推送屏蔽状态. */
bool CUserModel::getPushShield(uint32_t user_id, uint32_t* shield_status)
{
  bool rv = false;

  CDBManager* db_manager = CDBManager::getInstance();
  CDBConn* db_conn = db_manager->GetDBConn("teamtalk_slave");
  if (db_conn) {
    string str_sql = "select push_shield_status from IMUser where id="+int2string(user_id);
    CResultSet* result_set = db_conn->ExecuteQuery(str_sql.c_str());
    if(result_set) {
      if (result_set->Next()) {
        *shield_status = result_set->GetInt("push_shield_status");
        rv = true;
      }
      delete result_set;
    } else {
      log("getPushShield: no result set for sql:%s", str_sql.c_str());
    }
    db_manager->RelDBConn(db_conn);
  } else {
    log("getPushShield: no db connection for teamtalk_slave");
  }

  return rv;
}

/* db_proxy_server - business - UserAction.h */
#ifndef __USER_ACTION_H__
#define __USER_ACTION_H__

#include "ImPduBase.h"

/*  @param pPdu      收到的packet包指针
 *  @param conn_uuid 该包过来的socket 描述符
 *
 * getUserInfo 获取好友列表.
 * getChangedUser 获取有变更的用户列表.
 * changeUserSignInfo 更新用户个性签名.
 * doPushShield 设置APP应用夜间消息推送屏蔽.
 * doQueryPushShield 获取APP应用夜间消息推送屏蔽状态.
 */
namespace DB_PROXY {
  void getUserInfo(CImPdu* pPdu, uint32_t conn_uuid);
  void getChangedUser(CImPdu* pPdu, uint32_t conn_uuid);
  void changeUserSignInfo(CImPdu* pPdu, uint32_t conn_uuid);
  void doPushShield(CImPdu* pPdu, uint32_t conn_uuid);
  void doQueryPushShield(CImPdu* pPdu, uint32_t conn_uuid);
};

#endif /* __USER_ACTION_H__ */

/* db_proxy_server - business - UserAction.cpp */
#include <list>
#include <map>
#include "../ProxyConn.h"
#include "../DBPool.h"
#include "../SyncCenter.h"
#include "public_define.h"
#include "UserModel.h"
#include "IM.Login.pb.h"
#include "IM.Buddy.pb.h"
#include "IM.BaseDefine.pb.h"

namespace DB_PROXY {

/* 获取好友列表 */
void getUserInfo(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Buddy::IMUsersInfoReq msg;
  IM::Buddy::IMUsersInfoRsp msgResp;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    CImPdu* pPduRes = new CImPdu;

    uint32_t from_user_id = msg.user_id();
    uint32_t userCount = msg.user_id_list_size();
    std::list<uint32_t> idList;
    for(uint32_t i = 0; i < userCount;++i) {
      idList.push_back(msg.user_id_list(i));
    }
    std::list<IM::BaseDefine::UserInfo> lsUser;
    CUserModel::getInstance()->getUsers(idList, lsUser);
    msgResp.set_user_id(from_user_id);
    for(list<IM::BaseDefine::UserInfo>::iterator it=lsUser.begin();
        it!=lsUser.end(); ++it)
    {
      IM::BaseDefine::UserInfo* pUser = msgResp.add_user_info_list();
      //*pUser = *it;

      pUser->set_user_id(it->user_id());
      pUser->set_user_gender(it->user_gender());
      pUser->set_user_nick_name(it->user_nick_name());
      pUser->set_avatar_url(it->avatar_url());

      pUser->set_sign_info(it->sign_info());
      pUser->set_department_id(it->department_id());
      pUser->set_email(it->email());
      pUser->set_user_real_name(it->user_real_name());
      pUser->set_user_tel(it->user_tel());
      pUser->set_user_domain(it->user_domain());
      pUser->set_status(it->status());
    }
    log("userId=%u, userCnt=%u", from_user_id, userCount);
    msgResp.set_attach_data(msg.attach_data());
    pPduRes->SetPBMsg(&msgResp);
    pPduRes->SetSeqNum(pPdu->GetSeqNum());
    pPduRes->SetServiceId(IM::BaseDefine::SID_BUDDY_LIST);
    pPduRes->SetCommandId(IM::BaseDefine::CID_BUDDY_LIST_USER_INFO_RESPONSE);
    CProxyConn::AddResponsePdu(conn_uuid, pPduRes);
  }
  else
  {
    log("parse pb failed");
  }
}

/* 获取有变更的用户列表. */
void getChangedUser(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Buddy::IMAllUserReq msg;
  IM::Buddy::IMAllUserRsp msgResp;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    CImPdu* pPduRes = new CImPdu;

    uint32_t nReqId = msg.user_id();
    uint32_t nLastTime = msg.latest_update_time();
    uint32_t nLastUpdate = CSyncCenter::getInstance()->getLastUpdate();

    list<IM::BaseDefine::UserInfo> lsUsers;
    if( nLastUpdate > nLastTime)
    {
      list<uint32_t> lsIds;
      CUserModel::getInstance()->getChangedId(nLastTime, lsIds);
      CUserModel::getInstance()->getUsers(lsIds, lsUsers);
    }

    msgResp.set_user_id(nReqId);
    msgResp.set_latest_update_time(nLastTime);
    for (list<IM::BaseDefine::UserInfo>::iterator it=lsUsers.begin();
        it!=lsUsers.end(); ++it) {
      IM::BaseDefine::UserInfo* pUser = msgResp.add_user_list();
      //*pUser = *it;
      pUser->set_user_id(it->user_id());
      pUser->set_user_gender(it->user_gender());
      pUser->set_user_nick_name(it->user_nick_name());
      pUser->set_avatar_url(it->avatar_url());
      pUser->set_sign_info(it->sign_info());
      pUser->set_department_id(it->department_id());
      pUser->set_email(it->email());
      pUser->set_user_real_name(it->user_real_name());
      pUser->set_user_tel(it->user_tel());
      pUser->set_user_domain(it->user_domain());
      pUser->set_status(it->status());
    }
    log("userId=%u,nLastUpdate=%u, last_time=%u, userCnt=%u", nReqId,nLastUpdate, nLastTime, msgResp.user_list_size());
    msgResp.set_attach_data(msg.attach_data());
    pPduRes->SetPBMsg(&msgResp);
    pPduRes->SetSeqNum(pPdu->GetSeqNum());
    pPduRes->SetServiceId(IM::BaseDefine::SID_BUDDY_LIST);
    pPduRes->SetCommandId(IM::BaseDefine::CID_BUDDY_LIST_ALL_USER_RESPONSE);
    CProxyConn::AddResponsePdu(conn_uuid, pPduRes);
  }
  else
  {
    log("parse pb failed");
  }
}

/* 更新用户个性签名. */
void changeUserSignInfo(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Buddy::IMChangeSignInfoReq req;
  IM::Buddy::IMChangeSignInfoRsp resp;
  if(req.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength())) {
    uint32_t user_id = req.user_id();
    const string& sign_info = req.sign_info();

    bool result = CUserModel::getInstance()->updateUserSignInfo(user_id, sign_info);

    resp.set_user_id(user_id);
    resp.set_result_code(result ? 0 : 1);
    if (result) {
      resp.set_sign_info(sign_info);
      log("changeUserSignInfo sucess, user_id=%u, sign_info=%s", user_id, sign_info.c_str());
    } else {
      log("changeUserSignInfo false, user_id=%u, sign_info=%s", user_id, sign_info.c_str());
    }

    CImPdu* pdu_resp = new CImPdu();
    resp.set_attach_data(req.attach_data());
    pdu_resp->SetPBMsg(&resp);
    pdu_resp->SetSeqNum(pPdu->GetSeqNum());
    pdu_resp->SetServiceId(IM::BaseDefine::SID_BUDDY_LIST);
    pdu_resp->SetCommandId(IM::BaseDefine::CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE);
    CProxyConn::AddResponsePdu(conn_uuid, pdu_resp);

  } else {
    log("changeUserSignInfo: IMChangeSignInfoReq ParseFromArray failed!!!");
  }
}
  
/* 设置夜间APP应用消息推送屏蔽. */
void doPushShield(CImPdu* pPdu, uint32_t conn_uuid) {
  IM::Login::IMPushShieldReq req;
  IM::Login::IMPushShieldRsp resp;
  if(req.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength())) {
    uint32_t user_id = req.user_id();
    uint32_t shield_status = req.shield_status();
    // const string& sign_info = req.sign_info();

    bool result = CUserModel::getInstance()->updatePushShield(user_id, shield_status);

    resp.set_user_id(user_id);
    resp.set_result_code(result ? 0 : 1);
    if (result) {
      resp.set_shield_status(shield_status);
      log("doPushShield sucess, user_id=%u, shield_status=%u", user_id, shield_status);
    } else {
      log("doPushShield false, user_id=%u, shield_status=%u", user_id, shield_status);
    }


    CImPdu* pdu_resp = new CImPdu();
    resp.set_attach_data(req.attach_data());
    pdu_resp->SetPBMsg(&resp);
    pdu_resp->SetSeqNum(pPdu->GetSeqNum());
    pdu_resp->SetServiceId(IM::BaseDefine::SID_LOGIN);
    pdu_resp->SetCommandId(IM::BaseDefine::CID_LOGIN_RES_PUSH_SHIELD);
    CProxyConn::AddResponsePdu(conn_uuid, pdu_resp);

  } else {
    log("doPushShield: IMPushShieldReq ParseFromArray failed!!!");
  }
}

/* 获取夜间APP应用消息推送屏蔽状态. */
void doQueryPushShield(CImPdu* pPdu, uint32_t conn_uuid) {
  IM::Login::IMQueryPushShieldReq req;
  IM::Login::IMQueryPushShieldRsp resp;
  if(req.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength())) {
    uint32_t user_id = req.user_id();
    uint32_t shield_status = 0;

    bool result = CUserModel::getInstance()->getPushShield(user_id, &shield_status);

    resp.set_user_id(user_id);
    resp.set_result_code(result ? 0 : 1);
    if (result) {
      resp.set_shield_status(shield_status);
      log("doQueryPushShield sucess, user_id=%u, shield_status=%u", user_id, shield_status);
    } else {
      log("doQueryPushShield false, user_id=%u", user_id);
    }

    CImPdu* pdu_resp = new CImPdu();
    resp.set_attach_data(req.attach_data());
    pdu_resp->SetPBMsg(&resp);
    pdu_resp->SetSeqNum(pPdu->GetSeqNum());
    pdu_resp->SetServiceId(IM::BaseDefine::SID_LOGIN);
    pdu_resp->SetCommandId(IM::BaseDefine::CID_LOGIN_RES_QUERY_PUSH_SHIELD);
    CProxyConn::AddResponsePdu(conn_uuid, pdu_resp);
  } else {
    log("doQueryPushShield: IMQueryPushShieldReq ParseFromArray failed!!!");
  }
}

};

/* db_proxy_server - business - GroupModel.h */
#ifndef __IM_GROUP_MODEL__
#define __IM_GROUP_MODEL__

#include <stdio.h>
#include <iostream>
#include <string>
#include <list>
#include <map>
#include <set>
#include "MessageModel.h"
#include "IM.BaseDefine.pb.h"

using namespace std;

const uint32_t MAX_UNREAD_COUNT = 100;

/* Redis中的群哈希记录:
 * key    - filed  - value
 * 群组id - 用户id - 入群时间
 * group_member_GroupId - UserId - Createtime

 * createGroup 创建群
 * removeGroup 删除群
 * getUserGroup 获取用户加入的群列表
 * getUserGroupIds 获取用户加入的所有群列表
 * getGroupInfo 获取群列表,并填充用户
 * setPush 设置推送状态,屏蔽或者取消屏蔽
 * getPush 获取推送状态
 * modifyGroupMember 维护群(添加或者删除群成员)
 * getGroupUser 在Redis缓存中获取群成员
 * isInGroup 是否在群内(查Redis缓存)
 * updateGroupChat 更新群聊天最新时间
 * isValidateGroupId 群是否存在
 * getUserJoinTime 获取群成员加入时间

 * insertNewGroup 群组表插入一条新记录
 * insertNewMember 插入系列用户
 * getGroupVersion 获取群版本信息
 * hasModifyPermission 是否有修改群权限
 * addMember 添加群成员
 * removeMember 删除群成员
 * removeRepeatUser 删除重复的成员
 * removeSession 删除群会话接口
 * incGroupVersion 更新群版本号
 * clearGroupMember 删除所有群成员
 * fillGroupMember 填满群成员
 */
class CGroupModel {
public:
  virtual ~CGroupModel();
  static CGroupModel* getInstance();

public:
  uint32_t createGroup(uint32_t nUserId, const string& strGroupName, const string& strGroupAvatar, uint32_t nGroupType, set<uint32_t>& setMember);
  bool removeGroup(uint32_t nUserId, uint32_t nGroupId, list<uint32_t>& lsCurUserId);
  void getUserGroup(uint32_t nUserId, list<IM::BaseDefine::GroupVersionInfo>& lsGroup, uint32_t nGroupType);
  void getUserGroupIds(uint32_t nUserId, list<uint32_t>& lsGroupId, uint32_t nLimited = 100);
  void getGroupInfo(map<uint32_t,IM::BaseDefine::GroupVersionInfo>& mapGroupId, list<IM::BaseDefine::GroupInfo>& lsGroupInfo);
  bool setPush(uint32_t nUserId, uint32_t nGroupId, uint32_t nType, uint32_t nStatus);
  void getPush(uint32_t nGroupId, list<uint32_t>& lsUser, list<IM::BaseDefine::ShieldStatus>& lsPush);
  bool modifyGroupMember(uint32_t nUserId, uint32_t nGroupId, IM::BaseDefine::GroupModifyType nType, set<uint32_t>& setUserId, list<uint32_t>& lsCurUserId);
  void getGroupUser(uint32_t nGroupId, list<uint32_t>& lsUserId);
  bool isInGroup(uint32_t nUserId, uint32_t nGroupId);
  void updateGroupChat(uint32_t nGroupId);
  bool isValidateGroupId(uint32_t nGroupId);
  uint32_t getUserJoinTime(uint32_t nGroupId, uint32_t nUserId);
private:
  CGroupModel();

  bool insertNewGroup(uint32_t reqUserId, const string& groupName, const string& groupAvatar, uint32_t groupType, uint32_t memCnt, uint32_t& groupId);
  bool insertNewMember(uint32_t nGroupId,set<uint32_t>& setUsers);
  string GenerateGroupAvatar(uint32_t groupId);
  void getGroupVersion(list<uint32_t>&lsGroupId, list<IM::BaseDefine::GroupVersionInfo>& lsGroup, uint32_t nGroupType);
  bool hasModifyPermission(uint32_t nUserId, uint32_t nGroupId, IM::BaseDefine::GroupModifyType nType);
  bool addMember(uint32_t nGroupId, set<uint32_t>& setUser,list<uint32_t>& lsCurUserId);
  bool removeMember(uint32_t nGroupId, set<uint32_t>& setUser,list<uint32_t>& lsCurUserId);
  void removeRepeatUser(uint32_t nGroupId, set<uint32_t>& setUser);
  void removeSession(uint32_t nGroupId, const set<uint32_t>& lsUser);
  bool incGroupVersion(uint32_t nGroupId);
  void clearGroupMember(uint32_t nGroupId);

  void fillGroupMember(list<IM::BaseDefine::GroupInfo>& lsGroups);

private:
  static CGroupModel*	m_pInstance;
};

#endif /* defined(__IM_GROUP_MODEL__) */

/* db_proxy_server - business - GroupModel.cpp */
#include "../DBPool.h"
#include "../CachePool.h"
#include "GroupModel.h"
#include "ImPduBase.h"
#include "Common.h"
#include "AudioModel.h"
#include "UserModel.h"
#include "GroupMessageModel.h"
#include "public_define.h"
#include "SessionModel.h"

CGroupModel* CGroupModel::m_pInstance = NULL;

CGroupModel::CGroupModel()
{

}

CGroupModel::~CGroupModel()
{

}

CGroupModel* CGroupModel::getInstance()
{
  if (!m_pInstance) {
    m_pInstance = new CGroupModel();
  }
  return m_pInstance;
}

/**
 *  创建群
 *
 *  @param nUserId        创建者
 *  @param strGroupName   群名
 *  @param strGroupAvatar 群头像
 *  @param nGroupType     群类型1,固定群;2,临时群
 *  @param setMember      群成员列表，为了踢出重复的userId，使用set存储
 *
 *  @return 成功返回群Id，失败返回0;
 */
uint32_t CGroupModel::createGroup(uint32_t nUserId, const string& strGroupName, const string& strGroupAvatar, uint32_t nGroupType, set<uint32_t>& setMember)
{
  uint32_t nGroupId = INVALID_VALUE;
  do {
    if(strGroupName.empty()) {
      break;
    }
    if (setMember.empty()) {
      break;
    }
    // remove repeat user


    //insert IMGroup
    if(!insertNewGroup(nUserId, strGroupName, strGroupAvatar, nGroupType, (uint32_t)setMember.size(), nGroupId)) {
      break;
    }
    bool bRet = CGroupMessageModel::getInstance()->resetMsgId(nGroupId);
    if(!bRet)
    {
      log("reset msgId failed. groupId=%u", nGroupId);
    }

    //insert IMGroupMember
    clearGroupMember(nGroupId);
    insertNewMember(nGroupId, setMember);

  } while (false);

  return nGroupId;
}

/* 删除群 */
bool CGroupModel::removeGroup(uint32_t nUserId, uint32_t nGroupId, list<uint32_t>& lsCurUserId)
{
  bool bRet = false;
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  set<uint32_t> setGroupUsers;
  if(pDBConn)
  {
    string strSql = "select creator from IMGroup where id="+int2string(nGroupId);
    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if(pResultSet)
    {
      uint32_t nCreator;
      while (pResultSet->Next()) {
        nCreator = pResultSet->GetInt("creator");
      }

      if(0 == nCreator || nCreator == nUserId)
      {
        //设置群组不可用。
        strSql = "update IMGroup set status=0 where id="+int2string(nGroupId);
        bRet = pDBConn->ExecuteUpdate(strSql.c_str());
      }
      delete  pResultSet;
    }

    if (bRet) {
      strSql = "select userId from IMGroupMember where groupId="+int2string(nGroupId);
      CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
      if(pResultSet)
      {
        while (pResultSet->Next()) {
          uint32_t nId = pResultSet->GetInt("userId");
          setGroupUsers.insert(nId);
        }
        delete pResultSet;
      }
    }
    pDBManager->RelDBConn(pDBConn);
  }

  if(bRet)
  {
    bRet = removeMember(nGroupId, setGroupUsers, lsCurUserId);
  }

  return bRet;
}

/* 获取用户加入的群列表 */
void CGroupModel::getUserGroup(uint32_t nUserId, list<IM::BaseDefine::GroupVersionInfo>& lsGroup, uint32_t nGroupType)
{
  list<uint32_t> lsGroupId;
  getUserGroupIds(nUserId, lsGroupId,0);
  if(lsGroupId.size() != 0)
  {
    getGroupVersion(lsGroupId, lsGroup, nGroupType);
  }
}

/* 获取群列表,并填充用户 */
void CGroupModel::getGroupInfo(map<uint32_t,IM::BaseDefine::GroupVersionInfo>& mapGroupId, list<IM::BaseDefine::GroupInfo>& lsGroupInfo)
{ 
  if (!mapGroupId.empty())
  {
    CDBManager* pDBManager = CDBManager::getInstance();
    CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
    if (pDBConn)
    {
      string strClause;
      bool bFirst = true;
      for(auto it=mapGroupId.begin(); it!=mapGroupId.end(); ++it)
      {
        if(bFirst)
        {
          bFirst = false;
          strClause = int2string(it->first);
        }
        else
        {
          strClause += ("," + int2string(it->first));
        }
      }
      string strSql = "select * from IMGroup where id in (" + strClause  + ") order by updated desc";
      CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
      if(pResultSet)
      {
        while (pResultSet->Next()) {
          uint32_t nGroupId = pResultSet->GetInt("id");
          uint32_t nVersion = pResultSet->GetInt("version");
          if(mapGroupId[nGroupId].version() < nVersion)
          {
            IM::BaseDefine::GroupInfo cGroupInfo;
            cGroupInfo.set_group_id(nGroupId);
            cGroupInfo.set_version(nVersion);
            cGroupInfo.set_group_name(pResultSet->GetString("name"));
            cGroupInfo.set_group_avatar(pResultSet->GetString("avatar"));
            IM::BaseDefine::GroupType nGroupType = IM::BaseDefine::GroupType(pResultSet->GetInt("type"));
            if(IM::BaseDefine::GroupType_IsValid(nGroupType))
            {
              cGroupInfo.set_group_type(nGroupType);
              cGroupInfo.set_group_creator_id(pResultSet->GetInt("creator"));
              lsGroupInfo.push_back(cGroupInfo);
            }
            else
            {
              log("invalid groupType. groupId=%u, groupType=%u", nGroupId, nGroupType);
            }
          }
        }
        delete pResultSet;
      }
      else
      {
        log("no result set for sql:%s", strSql.c_str());
      }
      pDBManager->RelDBConn(pDBConn);
      if(!lsGroupInfo.empty())
      {
        fillGroupMember(lsGroupInfo);
      }
    }
    else
    {
      log("no db connection for teamtalk_slave");
    }
  }
  else
  {
    log("no ids in map");
  }
}

/* 维护群(添加或者删除群成员) */
bool CGroupModel::modifyGroupMember(uint32_t nUserId, uint32_t nGroupId, IM::BaseDefine::GroupModifyType nType, set<uint32_t>& setUserId, list<uint32_t>& lsCurUserId)
{
  bool bRet = false;
  if(hasModifyPermission(nUserId, nGroupId, nType))
  {
    switch (nType) {
      case IM::BaseDefine::GROUP_MODIFY_TYPE_ADD:
        bRet = addMember(nGroupId, setUserId, lsCurUserId);
        break;
      case IM::BaseDefine::GROUP_MODIFY_TYPE_DEL:
        bRet = removeMember(nGroupId, setUserId, lsCurUserId);
        removeSession(nGroupId, setUserId);
        break;
      default:
        log("unknown type:%u while modify group.%u->%u", nType, nUserId, nGroupId);
        break;
    }
    //if modify group member success, need to inc the group version and clear the user count;
    if(bRet)
    {
      incGroupVersion(nGroupId);
      for (auto it=setUserId.begin(); it!=setUserId.end(); ++it) {
        uint32_t nUserId=*it;
        CUserModel::getInstance()->clearUserCounter(nUserId, nGroupId, IM::BaseDefine::SESSION_TYPE_GROUP);
      }
    }
  }
  else
  {
    log("user:%u has no permission to modify group:%u", nUserId, nGroupId);
  }    return bRet;
}

/* 群组表插入一条新记录 */
bool CGroupModel::insertNewGroup(uint32_t nUserId, const string& strGroupName, const string& strGroupAvatar, uint32_t nGroupType, uint32_t nMemberCnt, uint32_t& nGroupId)
{
  bool bRet = false;
  nGroupId = INVALID_VALUE;
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if (pDBConn)
  {
    string strSql = "insert into IMGroup(`name`, `avatar`, `creator`, `type`,`userCnt`, `status`, `version`, `lastChated`, `updated`, `created`) "\
                     "values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

    CPrepareStatement* pStmt = new CPrepareStatement();
    if (pStmt->Init(pDBConn->GetMysql(), strSql))
    {
      uint32_t nCreated = (uint32_t)time(NULL);
      uint32_t index = 0;
      uint32_t nStatus = 0;
      uint32_t nVersion = 1;
      uint32_t nLastChat = 0;
      pStmt->SetParam(index++, strGroupName);
      pStmt->SetParam(index++, strGroupAvatar);
      pStmt->SetParam(index++, nUserId);
      pStmt->SetParam(index++, nGroupType);
      pStmt->SetParam(index++, nMemberCnt);
      pStmt->SetParam(index++, nStatus);
      pStmt->SetParam(index++, nVersion);
      pStmt->SetParam(index++, nLastChat);
      pStmt->SetParam(index++, nCreated);
      pStmt->SetParam(index++, nCreated);

      bRet = pStmt->ExecuteUpdate();
      if(bRet) {
        nGroupId = pStmt->GetInsertId();
      }
    }
    delete pStmt;
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
  return bRet;
}

/* 插入系列用户(如果用户在群成员表有记录则修改其状态status,再插入剩下的新用户,同步到Redis) */
bool CGroupModel::insertNewMember(uint32_t nGroupId, set<uint32_t>& setUsers)
{
  bool bRet = false;
  uint32_t nUserCnt = (uint32_t)setUsers.size();
  if(nGroupId != INVALID_VALUE &&  nUserCnt > 0)
  {
    CDBManager* pDBManager = CDBManager::getInstance();
    CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
    if (pDBConn)
    {
      uint32_t nCreated = (uint32_t)time(NULL);
      // 获取 已经存在群里的用户
      string strClause;
      bool bFirst = true;
      for (auto it=setUsers.begin(); it!=setUsers.end(); ++it)
      {
        if(bFirst)
        {
          bFirst = false;
          strClause = int2string(*it);
        }
        else
        {
          strClause += ("," + int2string(*it));
        }
      }
      string strSql = "select userId from IMGroupMember where groupId=" + int2string(nGroupId) + " and userId in (" + strClause + ")";
      CResultSet* pResult = pDBConn->ExecuteQuery(strSql.c_str());
      set<uint32_t> setHasUser;
      if(pResult)
      {
        while (pResult->Next()) {
          setHasUser.insert(pResult->GetInt("userId"));
        }
        delete pResult;
      }
      else
      {
        log("no result for sql:%s", strSql.c_str());
      }
      pDBManager->RelDBConn(pDBConn);

      pDBConn = pDBManager->GetDBConn("teamtalk_master");
      if (pDBConn)
      {
        CacheManager* pCacheManager = CacheManager::getInstance();
        CacheConn* pCacheConn = pCacheManager->GetCacheConn("group_member");
        if (pCacheConn)
        {
          // 设置已经存在群中人的状态
          if (!setHasUser.empty())
          {
            strClause.clear();
            bFirst = true;
            for (auto it=setHasUser.begin(); it!=setHasUser.end(); ++it) {
              if(bFirst)
              {
                bFirst = false;
                strClause = int2string(*it);
              }
              else
              {
                strClause += ("," + int2string(*it));
              }
            }

            strSql = "update IMGroupMember set status=0, updated="+int2string(nCreated)+" where groupId=" + int2string(nGroupId) + " and userId in (" + strClause + ")";
            pDBConn->ExecuteUpdate(strSql.c_str());
          }
          strSql = "insert into IMGroupMember(`groupId`, `userId`, `status`, `created`, `updated`) values\
                    (?,?,?,?,?)";

          //插入新成员
          auto it = setUsers.begin();
          uint32_t nStatus = 0;
          uint32_t nIncMemberCnt = 0;
          for (;it != setUsers.end();)
          {
            uint32_t nUserId = *it;
            if(setHasUser.find(nUserId) == setHasUser.end())
            {
              CPrepareStatement* pStmt = new CPrepareStatement();
              if (pStmt->Init(pDBConn->GetMysql(), strSql))
              {
                uint32_t index = 0;
                pStmt->SetParam(index++, nGroupId);
                pStmt->SetParam(index++, nUserId);
                pStmt->SetParam(index++, nStatus);
                pStmt->SetParam(index++, nCreated);
                pStmt->SetParam(index++, nCreated);
                pStmt->ExecuteUpdate();
                ++nIncMemberCnt;
                delete pStmt;
              }
              else
              {
                setUsers.erase(it++);
                delete pStmt;
                continue;
              }
            }
            ++it;
          }
          if(nIncMemberCnt != 0)
          {
            strSql = "update IMGroup set userCnt=userCnt+" + int2string(nIncMemberCnt) + " where id="+int2string(nGroupId);
            pDBConn->ExecuteUpdate(strSql.c_str());
          }

          //更新一份到redis中
          string strKey = "group_member_"+int2string(nGroupId);
          for(auto it = setUsers.begin(); it!=setUsers.end(); ++it)
          {
            pCacheConn->hset(strKey, int2string(*it), int2string(nCreated));
          }
          pCacheManager->RelCacheConn(pCacheConn);
          bRet = true;
        }
        else
        {
          log("no cache connection");
        }
        pDBManager->RelDBConn(pDBConn);
      }
      else
      {
        log("no db connection for teamtalk_master");
      }
    }
    else
    {
      log("no db connection for teamtalk_slave");
    }
  }
  return bRet;
}

/* 获取用户加入的所有群列表 */
void CGroupModel::getUserGroupIds(uint32_t nUserId, list<uint32_t>& lsGroupId, uint32_t nLimited)
{
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  if(pDBConn)
  {
    string strSql ;
    if (nLimited != 0) {
      strSql = "select groupId from IMGroupMember where userId=" + int2string(nUserId) + " and status = 0 order by updated desc, id desc limit " + int2string(nLimited);
    }
    else
    {
      strSql = "select groupId from IMGroupMember where userId=" + int2string(nUserId) + " and status = 0 order by updated desc, id desc";
    }

    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if(pResultSet)
    {
      while(pResultSet->Next())
      {
        uint32_t nGroupId = pResultSet->GetInt("groupId");
        lsGroupId.push_back(nGroupId);
      }
      delete pResultSet;
    }
    else
    {
      log("no result set for sql:%s", strSql.c_str());
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_slave");
  }
}

/* 获取群版本信息(群组表有群版本号字段,可更新群版本号) */
void CGroupModel::getGroupVersion(list<uint32_t> &lsGroupId, list<IM::BaseDefine::GroupVersionInfo> &lsGroup, uint32_t nGroupType)
{
  if(!lsGroupId.empty())
  {
    CDBManager* pDBManager = CDBManager::getInstance();
    CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
    if(pDBConn)
    {
      string strClause;
      bool bFirst = true;
      for(list<uint32_t>::iterator it=lsGroupId.begin(); it!=lsGroupId.end(); ++it)
      {
        if(bFirst)
        {
          bFirst = false;
          strClause = int2string(*it);
        }
        else
        {
          strClause += ("," + int2string(*it));
        }
      }

      string strSql = "select id,version from IMGroup where id in (" +  strClause  + ")";
      if(0 != nGroupType)
      {
        strSql += " and type="+int2string(nGroupType);
      }
      strSql += " order by updated desc";

      CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
      if(pResultSet)
      {
        while(pResultSet->Next())
        {
          IM::BaseDefine::GroupVersionInfo group;
          group.set_group_id(pResultSet->GetInt("id"));
          group.set_version(pResultSet->GetInt("version"));
          lsGroup.push_back(group);
        }
        delete pResultSet;
      }
      else
      {
        log("no result set for sql:%s", strSql.c_str());
      }
      pDBManager->RelDBConn(pDBConn);
    }
    else
    {
      log("no db connection for teamtalk_slave");
    }
  }
  else
  {
    log("group ids is empty");
  }
}

/* 是否在群内(查Redis缓存) */
bool CGroupModel::isInGroup(uint32_t nUserId, uint32_t nGroupId)
{
  bool bRet = false;
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("group_member");
  if (pCacheConn)
  {
    string strKey = "group_member_" + int2string(nGroupId);
    string strField = int2string(nUserId);
    string strValue = pCacheConn->hget(strKey, strField);
    pCacheManager->RelCacheConn(pCacheConn);
    if(!strValue.empty())
    {
      bRet = true;
    }
  }
  else
  {
    log("no cache connection for group_member");
  }
  return bRet;
}

/* 是否有修改群权限(是否是群主或者是否是临时群且添加群成员) */
bool CGroupModel::hasModifyPermission(uint32_t nUserId, uint32_t nGroupId, IM::BaseDefine::GroupModifyType nType)
{
  if(nUserId == 0) {
    return true;
  }

  bool bRet = false;
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  if(pDBConn)
  {
    string strSql = "select creator, type from IMGroup where id="+ int2string(nGroupId);
    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if(pResultSet)
    {
      while (pResultSet->Next())
      {
        uint32_t nCreator = pResultSet->GetInt("creator");
        IM::BaseDefine::GroupType nGroupType = IM::BaseDefine::GroupType(pResultSet->GetInt("type"));
        if(IM::BaseDefine::GroupType_IsValid(nGroupType))
        {
          if(IM::BaseDefine::GROUP_TYPE_TMP == nGroupType && IM::BaseDefine::GROUP_MODIFY_TYPE_ADD == nType)
          {
            bRet = true;
            break;
          }
          else
          {
            if(nCreator == nUserId)
            {
              bRet = true;
              break;
            }
          }
        }
      }
      delete pResultSet;
    }
    else
    {
      log("no result for sql:%s", strSql.c_str());
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_slave");
  }
  return bRet;
}

/* 添加群成员 */
bool CGroupModel::addMember(uint32_t nGroupId, set<uint32_t> &setUser, list<uint32_t>& lsCurUserId)
{
  // 去掉已经存在的用户ID
  removeRepeatUser(nGroupId, setUser);
  bool bRet = insertNewMember(nGroupId, setUser);
  getGroupUser(nGroupId,lsCurUserId);
  return bRet;
}

/* 删除群成员 */
bool CGroupModel::removeMember(uint32_t nGroupId, set<uint32_t> &setUser, list<uint32_t>& lsCurUserId)
{
  if(setUser.size() <= 0)
  {
    return true;
  }
  bool bRet = false;
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if(pDBConn)
  {
    CacheManager* pCacheManager = CacheManager::getInstance();
    CacheConn* pCacheConn = pCacheManager->GetCacheConn("group_member");
    if (pCacheConn)
    {
      string strClause ;
      bool bFirst = true;
      for(auto it= setUser.begin(); it!=setUser.end();++it)
      {
        if (bFirst) {
          bFirst = false;
          strClause = int2string(*it);
        }
        else
        {
          strClause += ("," + int2string(*it));
        }
      }
      string strSql = "update IMGroupMember set status=1 where  groupId =" + int2string(nGroupId) + " and userId in(" + strClause + ")";
      pDBConn->ExecuteUpdate(strSql.c_str());

      //从redis中删除成员
      string strKey = "group_member_"+ int2string(nGroupId);
      for (auto it=setUser.begin(); it!=setUser.end(); ++it) {
        string strField = int2string(*it);
        pCacheConn->hdel(strKey, strField);
      }
      pCacheManager->RelCacheConn(pCacheConn);
      bRet = true;
    }
    else
    {
      log("no cache connection");
    }
    pDBManager->RelDBConn(pDBConn);
    if (bRet)
    {
      getGroupUser(nGroupId,lsCurUserId);
    }
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
  return bRet;
}

/* 删除重复的成员(在Redis缓存中删除重复用户) */
void CGroupModel::removeRepeatUser(uint32_t nGroupId, set<uint32_t> &setUser)
{
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("group_member");
  if (pCacheConn)
  {
    string strKey = "group_member_"+int2string(nGroupId);
    for (auto it=setUser.begin(); it!=setUser.end();) {
      string strField = int2string(*it);
      string strValue = pCacheConn->hget(strKey, strField);
      if(!strValue.empty())
      {
        setUser.erase(it++);
      }
      else
      {
        ++it;
      }
    }
    pCacheManager->RelCacheConn(pCacheConn);
  }
  else
  {
    log("no cache connection for group_member");
  }
}

/* 设置推送状态,屏蔽或者取消屏蔽 */
bool CGroupModel::setPush(uint32_t nUserId, uint32_t nGroupId, uint32_t nType, uint32_t nStatus)
{
  bool bRet = false;
  if(!isInGroup(nUserId, nGroupId))
  {
    log("user:%d is not in group:%d", nUserId, nGroupId);
    return bRet;;
  }

  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("group_set");
  if(pCacheConn)
  {
    string strGroupKey = "group_set_" + int2string(nGroupId);
    string strField = int2string(nUserId) + "_" + int2string(nType);
    int nRet = pCacheConn->hset(strGroupKey, strField, int2string(nStatus));
    pCacheManager->RelCacheConn(pCacheConn);
    if(nRet != -1)
    {
      bRet = true;
    }
  }
  else
  {
    log("no cache connection for group_set");
  }
  return bRet;
}

/* 获取推送状态 */
void CGroupModel::getPush(uint32_t nGroupId, list<uint32_t>& lsUser, list<IM::BaseDefine::ShieldStatus>& lsPush)
{
  if (lsUser.empty()) {
    return;
  }
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("group_set");
  if(pCacheConn)
  {
    string strGroupKey = "group_set_" + int2string(nGroupId);
    map<string, string> mapResult;
    bool bRet = pCacheConn->hgetAll(strGroupKey, mapResult);
    pCacheManager->RelCacheConn(pCacheConn);
    if(bRet)
    {
      for(auto it=lsUser.begin(); it!=lsUser.end(); ++it)
      {
        string strField = int2string(*it) + "_" + int2string(IM_GROUP_SETTING_PUSH);
        auto itResult = mapResult.find(strField);
        IM::BaseDefine::ShieldStatus status;
        status.set_group_id(nGroupId);
        status.set_user_id(*it);
        if(itResult != mapResult.end())
        {
          status.set_shield_status(string2int(itResult->second));
        }
        else
        {
          status.set_shield_status(0);
        }
        lsPush.push_back(status);
      }
    }
    else
    {
      log("hgetall %s failed!", strGroupKey.c_str());
    }
  }
  else
  {
    log("no cache connection for group_set");
  }
}

/* 在Redis缓存中获取群成员 */
void CGroupModel::getGroupUser(uint32_t nGroupId, list<uint32_t> &lsUserId)
{
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("group_member");
  if (pCacheConn)
  {
    string strKey = "group_member_" + int2string(nGroupId);
    map<string, string> mapAllUser;
    bool bRet = pCacheConn->hgetAll(strKey, mapAllUser);
    pCacheManager->RelCacheConn(pCacheConn);
    if(bRet)
    {
      for (auto it=mapAllUser.begin(); it!=mapAllUser.end(); ++it) {
        uint32_t nUserId = string2int(it->first);
        lsUserId.push_back(nUserId);
      }
    }
    else
    {
      log("hgetall %s failed!", strKey.c_str());
    }
  }
  else
  {
    log("no cache connection for group_member");
  }
}

/* 更新群聊天最新时间 */
void CGroupModel::updateGroupChat(uint32_t nGroupId)
{
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if(pDBConn)
  {
    uint32_t nNow = (uint32_t)time(NULL);
    string strSql = "update IMGroup set lastChated=" + int2string(nNow) + " where id=" + int2string(nGroupId);
    pDBConn->ExecuteUpdate(strSql.c_str());
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
}

//bool CGroupModel::isValidateGroupId(uint32_t nGroupId)
//{
//    bool bRet = false;
//    CDBManager* pDBManager = CDBManager::getInstance();
//    CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
//    if(pDBConn)
//    {
//        string strSql = "select id from IMGroup where id=" + int2string(nGroupId)+" and status=0";
//        CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
//        if(pResultSet && pResultSet->Next())
//        {
//            bRet =  true;
//            delete pResultSet;
//        }
//        pDBManager->RelDBConn(pDBConn);
//    }
//    else
//    {
//        log("no db connection for teamtalk_slave");
//    }
//    return bRet;
//}

/* 群是否存在 */
bool CGroupModel::isValidateGroupId(uint32_t nGroupId)
{
  bool bRet = false;
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("group_member");
  if(pCacheConn)
  {
    string strKey = "group_member_"+int2string(nGroupId);
    bRet = pCacheConn->isExists(strKey);
    pCacheManager->RelCacheConn(pCacheConn);
  }
  return bRet;
}

/* 删除群会话接口 */
void CGroupModel::removeSession(uint32_t nGroupId, const set<uint32_t> &setUser)
{
  for(auto it=setUser.begin(); it!=setUser.end(); ++it)
  {
    uint32_t nUserId=*it;
    uint32_t nSessionId = CSessionModel::getInstance()->getSessionId(nUserId, nGroupId, IM::BaseDefine::SESSION_TYPE_GROUP, false);
    CSessionModel::getInstance()->removeSession(nSessionId);
  }
}

/* 更新群版本号 */
bool CGroupModel::incGroupVersion(uint32_t nGroupId)
{
  bool bRet = false;
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if(pDBConn)
  {
    string strSql = "update IMGroup set version=version+1 where id="+int2string(nGroupId);
    if(pDBConn->ExecuteUpdate(strSql.c_str()))
    {
      bRet = true;
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
  return  bRet;
}

/* 填满群成员 */
void CGroupModel::fillGroupMember(list<IM::BaseDefine::GroupInfo>& lsGroups)
{
  for (auto it=lsGroups.begin(); it!=lsGroups.end(); ++it) {
    list<uint32_t> lsUserIds;
    uint32_t nGroupId = it->group_id();
    getGroupUser(nGroupId, lsUserIds);
    for(auto itUserId=lsUserIds.begin(); itUserId!=lsUserIds.end(); ++itUserId)
    {
      it->add_group_member_list(*itUserId);
    }
  }
}

/* 获取群成员加入时间 */
uint32_t CGroupModel::getUserJoinTime(uint32_t nGroupId, uint32_t nUserId)
{
  uint32_t nTime = 0;
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("group_member");
  if (pCacheConn)
  {
    string strKey = "group_member_" + int2string(nGroupId);
    string strField = int2string(nUserId);
    string strValue = pCacheConn->hget(strKey, strField);
    pCacheManager->RelCacheConn(pCacheConn);
    if (!strValue.empty()) {
      nTime = string2int(strValue);
    }
  }
  else
  {
    log("no cache connection for group_member");
  }
  return  nTime;
}

/* 删除所有群成员 */
void CGroupModel::clearGroupMember(uint32_t nGroupId)
{
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if(pDBConn)
  {
    string strSql = "delete from IMGroupMember where groupId="+int2string(nGroupId);
    pDBConn->ExecuteUpdate(strSql.c_str());
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("group_member");
  if(pCacheConn)
  {
    string strKey = "group_member_" + int2string(nGroupId);
    map<string, string> mapRet;
    bool bRet = pCacheConn->hgetAll(strKey, mapRet);
    if(bRet)
    {
      for(auto it=mapRet.begin(); it!=mapRet.end(); ++it)
      {
        pCacheConn->hdel(strKey, it->first);
      }
    }
    else
    {
      log("hgetall %s failed", strKey.c_str());
    }
    pCacheManager->RelCacheConn(pCacheConn);
  }
  else
  {
    log("no cache connection for group_member");
  }
}

/* db_proxy_server - business - GroupAction.h */
#ifndef GROUPACTION_H_
#define GROUPACTION_H_

#include "ImPduBase.h"

/* createGroup 创建群组
 * getNormalGroupList 获取正式群列表
 * getGroupInfo 获取群信息
 * modifyMember 修改群成员，增加或删除
 * setGroupPush 设置群组信息推送，屏蔽或者取消屏蔽
 * getGroupPush 获取一个群的推送设置
 */
namespace DB_PROXY {

void createGroup(CImPdu* pPdu, uint32_t conn_uuid);
void getNormalGroupList(CImPdu* pPdu, uint32_t conn_uuid);
void getGroupInfo(CImPdu* pPdu, uint32_t conn_uuid);
void modifyMember(CImPdu* pPdu, uint32_t conn_uuid);
void setGroupPush(CImPdu* pPdu, uint32_t conn_uuid);
void getGroupPush(CImPdu* pPdu, uint32_t conn_uuid);

};

#endif /* GROUPACTION_H_ */

/* db_proxy_server - business - GroupAction.cpp */
#include "../ProxyConn.h"
#include "GroupAction.h"
#include "GroupModel.h"
#include "IM.Group.pb.h"
#include "IM.BaseDefine.pb.h"
#include "public_define.h"
#include "IM.Server.pb.h"

namespace DB_PROXY {
    
/**
 *  创建群组
 *
 *  @param pPdu      收到的packet包指针
 *  @param conn_uuid 该包过来的socket 描述符
 */
void createGroup(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Group::IMGroupCreateReq msg;
  IM::Group::IMGroupCreateRsp msgResp;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    CImPdu* pPduRes = new CImPdu;

    uint32_t nUserId = msg.user_id();
    string strGroupName = msg.group_name();
    IM::BaseDefine::GroupType nGroupType = msg.group_type();
    if(IM::BaseDefine::GroupType_IsValid(nGroupType))
    {
      string strGroupAvatar = msg.group_avatar();
      set<uint32_t> setMember;
      uint32_t nMemberCnt = msg.member_id_list_size();
      for(uint32_t i=0; i<nMemberCnt; ++i)
      {
        uint32_t nUserId = msg.member_id_list(i);
        setMember.insert(nUserId);
      }
      log("createGroup.%d create %s, userCnt=%u", nUserId, strGroupName.c_str(), setMember.size());

      uint32_t nGroupId = CGroupModel::getInstance()->createGroup(nUserId, strGroupName, strGroupAvatar, nGroupType, setMember);
      msgResp.set_user_id(nUserId);
      msgResp.set_group_name(strGroupName);
      for(auto it=setMember.begin(); it!=setMember.end();++it)
      {
        msgResp.add_user_id_list(*it);
      }
      if(nGroupId != INVALID_VALUE)
      {
        msgResp.set_result_code(0);
        msgResp.set_group_id(nGroupId);
      }
      else
      {
        msgResp.set_result_code(1);
      }


      log("createGroup.%d create %s, userCnt=%u, result:%d", nUserId, strGroupName.c_str(), setMember.size(), msgResp.result_code());

      msgResp.set_attach_data(msg.attach_data());
      pPduRes->SetPBMsg(&msgResp);
      pPduRes->SetSeqNum(pPdu->GetSeqNum());
      pPduRes->SetServiceId(IM::BaseDefine::SID_GROUP);
      pPduRes->SetCommandId(IM::BaseDefine::CID_GROUP_CREATE_RESPONSE);
      CProxyConn::AddResponsePdu(conn_uuid, pPduRes);
    }
    else
    {
      log("invalid group type.userId=%u, groupType=%u, groupName=%s", nUserId, nGroupType, strGroupName.c_str());
    }
  }
  else
  {
    log("parse pb failed");
  }
}

/**
 *  获取正式群列表
 *
 *  @param pPdu      收到的packet包指针
 *  @param conn_uuid 该包过来的socket 描述符
 */
void getNormalGroupList(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Group::IMNormalGroupListReq msg;
  IM::Group::IMNormalGroupListRsp msgResp;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    CImPdu* pPduRes = new CImPdu;

    uint32_t nUserId = msg.user_id();

    list<IM::BaseDefine::GroupVersionInfo> lsGroup;
    CGroupModel::getInstance()->getUserGroup(nUserId, lsGroup, IM::BaseDefine::GROUP_TYPE_NORMAL);
    msgResp.set_user_id(nUserId);
    for(auto it=lsGroup.begin(); it!=lsGroup.end(); ++it)
    {
      IM::BaseDefine::GroupVersionInfo* pGroupVersion = msgResp.add_group_version_list();
      pGroupVersion->set_group_id(it->group_id());
      pGroupVersion->set_version(it->version());
    }

    log("getNormalGroupList. userId=%u, count=%d", nUserId, msgResp.group_version_list_size());

    msgResp.set_attach_data(msg.attach_data());
    pPduRes->SetPBMsg(&msgResp);
    pPduRes->SetSeqNum(pPdu->GetSeqNum());
    pPduRes->SetServiceId(IM::BaseDefine::SID_GROUP);
    pPduRes->SetCommandId(IM::BaseDefine::CID_GROUP_NORMAL_LIST_RESPONSE);
    CProxyConn::AddResponsePdu(conn_uuid, pPduRes);
  }
  else
  {
    log("parse pb failed");
  }
}

/**
 *  获取群信息
 *
 *  @param pPdu      收到的packet包指针
 *  @param conn_uuid 该包过来的socket 描述符
 */
void getGroupInfo(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Group::IMGroupInfoListReq msg;
  IM::Group::IMGroupInfoListRsp msgResp;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    CImPdu* pPduRes = new CImPdu;
    uint32_t nUserId = msg.user_id();
    uint32_t nGroupCnt = msg.group_version_list_size();

    map<uint32_t, IM::BaseDefine::GroupVersionInfo> mapGroupId;
    for(uint32_t i=0; i<nGroupCnt; ++i)
    {
      IM::BaseDefine::GroupVersionInfo groupInfo = msg.group_version_list(i);
      if(CGroupModel::getInstance()->isValidateGroupId(groupInfo.group_id()))
      {
        mapGroupId[groupInfo.group_id()] = groupInfo;
      }
    }
    list<IM::BaseDefine::GroupInfo> lsGroupInfo;
    CGroupModel::getInstance()->getGroupInfo(mapGroupId, lsGroupInfo);

    msgResp.set_user_id(nUserId);
    for(auto it=lsGroupInfo.begin(); it!=lsGroupInfo.end(); ++it)
    {
      IM::BaseDefine::GroupInfo* pGroupInfo = msgResp.add_group_info_list();
      //            *pGroupInfo = *it;
      pGroupInfo->set_group_id(it->group_id());
      pGroupInfo->set_version(it->version());
      pGroupInfo->set_group_name(it->group_name());
      pGroupInfo->set_group_avatar(it->group_avatar());
      pGroupInfo->set_group_creator_id(it->group_creator_id());
      pGroupInfo->set_group_type(it->group_type());
      pGroupInfo->set_shield_status(it->shield_status());
      uint32_t nGroupMemberCnt = it->group_member_list_size();
      for (uint32_t i=0; i<nGroupMemberCnt; ++i) {
        uint32_t userId = it->group_member_list(i);
        pGroupInfo->add_group_member_list(userId);
      }
    }

    log("userId=%u, requestCount=%u", nUserId, nGroupCnt);

    msgResp.set_attach_data(msg.attach_data());
    pPduRes->SetPBMsg(&msgResp);
    pPduRes->SetSeqNum(pPdu->GetSeqNum());
    pPduRes->SetServiceId(IM::BaseDefine::SID_GROUP);
    pPduRes->SetCommandId(IM::BaseDefine::CID_GROUP_INFO_RESPONSE);
    CProxyConn::AddResponsePdu(conn_uuid, pPduRes);
  }
  else
  {
    log("parse pb failed");
  }
}
/**
 *  修改群成员，增加或删除
 *
 *  @param pPdu      收到的packet包指针
 *  @param conn_uuid 该包过来的socket 描述符
 */
void modifyMember(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Group::IMGroupChangeMemberReq msg;
  IM::Group::IMGroupChangeMemberRsp msgResp;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    uint32_t nUserId = msg.user_id();
    uint32_t nGroupId = msg.group_id();
    IM::BaseDefine::GroupModifyType nType = msg.change_type();
    if (IM::BaseDefine::GroupModifyType_IsValid(nType) &&
        CGroupModel::getInstance()->isValidateGroupId(nGroupId)) {

      CImPdu* pPduRes = new CImPdu;

      uint32_t nCnt = msg.member_id_list_size();
      set<uint32_t> setUserId;
      for(uint32_t i=0; i<nCnt;++i)
      {
        setUserId.insert(msg.member_id_list(i));
      }
      list<uint32_t> lsCurUserId;
      bool bRet = CGroupModel::getInstance()->modifyGroupMember(nUserId, nGroupId, nType, setUserId, lsCurUserId);
      msgResp.set_user_id(nUserId);
      msgResp.set_group_id(nGroupId);
      msgResp.set_change_type(nType);
      msgResp.set_result_code(bRet?0:1);
      if(bRet)
      {
        for(auto it=setUserId.begin(); it!=setUserId.end(); ++it)
        {
          msgResp.add_chg_user_id_list(*it);
        }

        for(auto it=lsCurUserId.begin(); it!=lsCurUserId.end(); ++it)
        {
          msgResp.add_cur_user_id_list(*it);
        }
      }
      log("userId=%u, groupId=%u, result=%u, changeCount:%u, currentCount=%u",nUserId, nGroupId,  bRet?0:1, msgResp.chg_user_id_list_size(), msgResp.cur_user_id_list_size());
      msgResp.set_attach_data(msg.attach_data());
      pPduRes->SetPBMsg(&msgResp);
      pPduRes->SetSeqNum(pPdu->GetSeqNum());
      pPduRes->SetServiceId(IM::BaseDefine::SID_GROUP);
      pPduRes->SetCommandId(IM::BaseDefine::CID_GROUP_CHANGE_MEMBER_RESPONSE);
      CProxyConn::AddResponsePdu(conn_uuid, pPduRes);
    }
    else
    {
      log("invalid groupModifyType or groupId. userId=%u, groupId=%u, groupModifyType=%u", nUserId, nGroupId, nType);
    }

  }
  else
  {
    log("parse pb failed");
  }
}

/**
 *  设置群组信息推送，屏蔽或者取消屏蔽
 *
 *  @param pPdu      收到的packet包指针
 *  @param conn_uuid 该包过来的socket 描述符
 */
void setGroupPush(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Group::IMGroupShieldReq msg;
  IM::Group::IMGroupShieldRsp msgResp;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    uint32_t nUserId = msg.user_id();
    uint32_t nGroupId = msg.group_id();
    uint32_t nStatus = msg.shield_status();
    if(CGroupModel::getInstance()->isValidateGroupId(nGroupId))
    {

      CImPdu* pPduRes = new CImPdu;
      bool bRet = CGroupModel::getInstance()->setPush(nUserId, nGroupId, IM_GROUP_SETTING_PUSH, nStatus);

      msgResp.set_user_id(nUserId);
      msgResp.set_group_id(nGroupId);
      msgResp.set_result_code(bRet?0:1);

      log("userId=%u, groupId=%u, result=%u", nUserId, nGroupId, msgResp.result_code());

      msgResp.set_attach_data(msg.attach_data());
      pPduRes->SetPBMsg(&msgResp);
      pPduRes->SetSeqNum(pPdu->GetSeqNum());
      pPduRes->SetServiceId(IM::BaseDefine::SID_GROUP);
      pPduRes->SetCommandId(IM::BaseDefine::CID_GROUP_SHIELD_GROUP_RESPONSE);
      CProxyConn::AddResponsePdu(conn_uuid, pPduRes);
    }
    else
    {
      log("Invalid group.userId=%u, groupId=%u", nUserId, nGroupId);
    }
  }
  else
  {
    log("parse pb failed");
  }
}

/**
 *  获取一个群的推送设置
 *
 *  @param pPdu      收到的packet包指针
 *  @param conn_uuid 该包过来的socket 描述符
 */
void getGroupPush(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Server::IMGroupGetShieldReq msg;
  IM::Server::IMGroupGetShieldRsp msgResp;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    uint32_t nGroupId = msg.group_id();
    uint32_t nUserCnt = msg.user_id_size();
    if(CGroupModel::getInstance()->isValidateGroupId(nGroupId))
    {
      CImPdu* pPduRes = new CImPdu;
      list<uint32_t> lsUser;
      for(uint32_t i=0; i<nUserCnt; ++i)
      {
        lsUser.push_back(msg.user_id(i));
      }
      list<IM::BaseDefine::ShieldStatus> lsPush;
      CGroupModel::getInstance()->getPush(nGroupId, lsUser, lsPush);

      msgResp.set_group_id(nGroupId);
      for (auto it=lsPush.begin(); it!=lsPush.end(); ++it) {
        IM::BaseDefine::ShieldStatus* pStatus = msgResp.add_shield_status_list();
        //            *pStatus = *it;
        pStatus->set_user_id(it->user_id());
        pStatus->set_group_id(it->group_id());
        pStatus->set_shield_status(it->shield_status());
      }

      log("groupId=%u, count=%u", nGroupId, nUserCnt);

      msgResp.set_attach_data(msg.attach_data());
      pPduRes->SetPBMsg(&msgResp);
      pPduRes->SetSeqNum(pPdu->GetSeqNum());
      pPduRes->SetServiceId(IM::BaseDefine::SID_OTHER);
      pPduRes->SetCommandId(IM::BaseDefine::CID_OTHER_GET_SHIELD_RSP);
      CProxyConn::AddResponsePdu(conn_uuid, pPduRes);
    }
    else
    {
      log("Invalid groupId. nGroupId=%u", nGroupId);
    }
  }
  else
  {
    log("parse pb failed");
  }
}

}

/* db_proxy_server - business - SessionModel.h */
#ifndef __SESSIONMODEL_H__
#define __SESSIONMODEL_H__

#include "ImPduBase.h"
#include "IM.BaseDefine.pb.h"

/* getRecentSession 获取最近会话列表
 * getSessionId 获取用户与其他用户会话接口的id.
 * updateSession 根据id更新会话接口的会话时间.
 * removeSession 根据id删除会话接口.(实际只是更新了会话状态).
 * addSession 插入新的会话接口(如果之前已经删除该会话,重新更新该会话id状态).
 * fillSessionMsg 在用户所有的会话接口中填充聊天内容.
 */
class CSessionModel
{
public:
  static CSessionModel* getInstance();
  ~CSessionModel() {}

  void getRecentSession(uint32_t userId, uint32_t lastTime, list<IM::BaseDefine::ContactSessionInfo>& lsContact);
  uint32_t getSessionId(uint32_t nUserId, uint32_t nPeerId, uint32_t nType, bool isAll);
  bool updateSession(uint32_t nSessionId, uint32_t nUpdateTime);
  bool removeSession(uint32_t nSessionId);
  uint32_t addSession(uint32_t nUserId, uint32_t nPeerId, uint32_t nType);

private:
  CSessionModel() {};
  void fillSessionMsg(uint32_t nUserId, list<IM::BaseDefine::ContactSessionInfo>& lsContact);
private:
  static CSessionModel* m_pInstance;
};

#endif /*defined(__SESSIONMODEL_H__) */

/* db_proxy_server - business - SessionModel.cpp */
#include "SessionModel.h"
#include "DBPool.h"
#include "MessageModel.h"
#include "GroupMessageModel.h"

CSessionModel* CSessionModel::m_pInstance = NULL;

CSessionModel* CSessionModel::getInstance()
{
  if (!m_pInstance) {
    m_pInstance = new CSessionModel();
  }

  return m_pInstance;
}

/* 获取最近会话列表 */
void CSessionModel::getRecentSession(uint32_t nUserId, uint32_t lastTime, list<IM::BaseDefine::ContactSessionInfo>& lsContact)
{
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  if (pDBConn)
  {
    string strSql = "select * from IMRecentSession where userId = " + int2string(nUserId) + " and status = 0 and updated >" + int2string(lastTime) + " order by updated desc limit 100";

    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if (pResultSet)
    {
      while (pResultSet->Next())
      {
        IM::BaseDefine::ContactSessionInfo cRelate;
        uint32_t nPeerId = pResultSet->GetInt("peerId");
        cRelate.set_session_id(nPeerId);
        cRelate.set_session_status(::IM::BaseDefine::SessionStatusType(pResultSet->GetInt("status")));

        IM::BaseDefine::SessionType nSessionType = IM::BaseDefine::SessionType(pResultSet->GetInt("type"));
        if(IM::BaseDefine::SessionType_IsValid(nSessionType))
        {
          cRelate.set_session_type(IM::BaseDefine::SessionType(nSessionType));
          cRelate.set_updated_time(pResultSet->GetInt("updated"));
          lsContact.push_back(cRelate);
        }
        else
        {
          log("invalid sessionType. userId=%u, peerId=%u, sessionType=%u", nUserId, nPeerId, nSessionType);
        }
      }
      delete pResultSet;
    }
    else
    {
      log("no result set for sql: %s", strSql.c_str());
    }
    pDBManager->RelDBConn(pDBConn);
    if(!lsContact.empty())
    {
      fillSessionMsg(nUserId, lsContact);
    }
  }
  else
  {
    log("no db connection for teamtalk_slave");
  }
}

/* 获取用户与其他用户会话接口的id. */
uint32_t CSessionModel::getSessionId(uint32_t nUserId, uint32_t nPeerId, uint32_t nType, bool isAll)
{
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  uint32_t nSessionId = INVALID_VALUE;
  if(pDBConn)
  {
    string strSql;
    if (isAll) {
      strSql= "select id from IMRecentSession where userId=" + int2string(nUserId) + " and peerId=" + int2string(nPeerId) + " and type=" + int2string(nType);
    }
    else
    {
      strSql= "select id from IMRecentSession where userId=" + int2string(nUserId) + " and peerId=" + int2string(nPeerId) + " and type=" + int2string(nType) + " and status=0";
    }

    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if(pResultSet)
    {
      while (pResultSet->Next()) {
        nSessionId = pResultSet->GetInt("id");
      }
      delete pResultSet;
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_slave");
  }
  return nSessionId;
}

/* 根据id更新会话接口的会话时间. */
bool CSessionModel::updateSession(uint32_t nSessionId, uint32_t nUpdateTime)
{
  bool bRet = false;
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if (pDBConn)
  {
    string strSql = "update IMRecentSession set `updated`="+int2string(nUpdateTime) + " where id="+int2string(nSessionId);
    bRet = pDBConn->ExecuteUpdate(strSql.c_str());
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
  return bRet;
}

/* 根据id删除会话接口.(实际只是更新了会话状态). */
bool CSessionModel::removeSession(uint32_t nSessionId)
{
  bool bRet = false;
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if (pDBConn)
  {
    uint32_t nNow = (uint32_t) time(NULL);
    string strSql = "update IMRecentSession set status = 1, updated="+int2string(nNow)+" where id=" + int2string(nSessionId);
    bRet = pDBConn->ExecuteUpdate(strSql.c_str());
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
  return bRet;
}

/* 插入新的会话接口(如果之前已经删除该会话,重新更新该会话id状态). */
uint32_t CSessionModel::addSession(uint32_t nUserId, uint32_t nPeerId, uint32_t nType)
{
  uint32_t nSessionId = INVALID_VALUE;

  nSessionId = getSessionId(nUserId, nPeerId, nType, true);
  uint32_t nTimeNow = time(NULL);
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if (pDBConn)
  {
    if(INVALID_VALUE != nSessionId)
    {
      string strSql = "update IMRecentSession set status=0, updated=" + int2string(nTimeNow) + " where id=" + int2string(nSessionId);
      bool bRet = pDBConn->ExecuteUpdate(strSql.c_str());
      if(!bRet)
      {
        nSessionId = INVALID_VALUE;
      }
      log("has relation ship set status");
    }
    else
    {
      string strSql = "insert into IMRecentSession (`userId`,`peerId`,`type`,`status`,`created`,`updated`) values(?,?,?,?,?,?)";
      // 必须在释放连接前delete CPrepareStatement对象，否则有可能多个线程操作mysql对象，会crash
      CPrepareStatement* stmt = new CPrepareStatement();
      if (stmt->Init(pDBConn->GetMysql(), strSql))
      {
        uint32_t nStatus = 0;
        uint32_t index = 0;
        stmt->SetParam(index++, nUserId);
        stmt->SetParam(index++, nPeerId);
        stmt->SetParam(index++, nType);
        stmt->SetParam(index++, nStatus);
        stmt->SetParam(index++, nTimeNow);
        stmt->SetParam(index++, nTimeNow);
        bool bRet = stmt->ExecuteUpdate();
        if (bRet)
        {
          nSessionId = pDBConn->GetInsertId();
        }
        else
        {
          log("insert message failed. %s", strSql.c_str());
        }
      }
      delete stmt;
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
  return nSessionId;
}

/* 在用户所有的会话接口中填充聊天内容. */
void CSessionModel::fillSessionMsg(uint32_t nUserId, list<IM::BaseDefine::ContactSessionInfo>& lsContact)
{
  for (auto it=lsContact.begin(); it!=lsContact.end();)
  {
    uint32_t nMsgId = 0;
    string strMsgData;
    IM::BaseDefine::MsgType nMsgType;
    uint32_t nFromId = 0;
    if( it->session_type() == IM::BaseDefine::SESSION_TYPE_SINGLE)
    {
      nFromId = it->session_id();
      CMessageModel::getInstance()->getLastMsg(it->session_id(), nUserId, nMsgId, strMsgData, nMsgType);
    }
    else
    {
      CGroupMessageModel::getInstance()->getLastMsg(it->session_id(), nMsgId, strMsgData, nMsgType, nFromId);
    }
    if(!IM::BaseDefine::MsgType_IsValid(nMsgType))
    {
      it = lsContact.erase(it);
    }
    else
    {
      it->set_latest_msg_from_user_id(nFromId);
      it->set_latest_msg_id(nMsgId);
      it->set_latest_msg_data(strMsgData);
      it->set_latest_msg_type(nMsgType);
      ++it;
    }
  }
}

/* db_proxy_server - business - RecentSession.h */
#ifndef FRIEND_SHIP_H_
#define FRIEND_SHIP_H_

#include "ImPduBase.h"

/* getRecentSession 获取最近会话接口(多个会话)
 * deleteRecentSession 删除会话接口(单个会话)
 */
namespace DB_PROXY {
  void getRecentSession(CImPdu* pPdu, uint32_t conn_uuid);
  void deleteRecentSession(CImPdu* pPdu, uint32_t conn_uuid);
};

#endif /* FRIEND_SHIP_H_ */

/* db_proxy_server - business - RecentSession.cpp */
#include <list>
#include <vector>
#include "../ProxyConn.h"
#include "../DBPool.h"
#include "../CachePool.h"
#include "SessionModel.h"
#include "RecentSession.h"
#include "UserModel.h"
#include "GroupModel.h"
#include "IM.Buddy.pb.h"

using namespace std;

namespace DB_PROXY {
/**
 *  获取最近会话接口(多个会话)
 *
 *  @param pPdu      收到的packet包指针
 *  @param conn_uuid 该包过来的socket 描述符
 */
void getRecentSession(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Buddy::IMRecentContactSessionReq msg;
  IM::Buddy::IMRecentContactSessionRsp msgResp;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    CImPdu* pPduResp = new CImPdu;

    uint32_t nUserId = msg.user_id();
    uint32_t nLastTime = msg.latest_update_time();

    //获取最近联系人列表
    list<IM::BaseDefine::ContactSessionInfo> lsContactList;
    CSessionModel::getInstance()->getRecentSession(nUserId, nLastTime, lsContactList);
    msgResp.set_user_id(nUserId);
    for(auto it=lsContactList.begin(); it!=lsContactList.end(); ++it)
    {
      IM::BaseDefine::ContactSessionInfo* pContact = msgResp.add_contact_session_list();
      //*pContact = *it;
      pContact->set_session_id(it->session_id());
      pContact->set_session_type(it->session_type());
      pContact->set_session_status(it->session_status());
      pContact->set_updated_time(it->updated_time());
      pContact->set_latest_msg_id(it->latest_msg_id());
      pContact->set_latest_msg_data(it->latest_msg_data());
      pContact->set_latest_msg_type(it->latest_msg_type());
      pContact->set_latest_msg_from_user_id(it->latest_msg_from_user_id());
    }

    log("userId=%u, last_time=%u, count=%u", nUserId, nLastTime, msgResp.contact_session_list_size());

    msgResp.set_attach_data(msg.attach_data());
    pPduResp->SetPBMsg(&msgResp);
    pPduResp->SetSeqNum(pPdu->GetSeqNum());
    pPduResp->SetServiceId(IM::BaseDefine::SID_BUDDY_LIST);
    pPduResp->SetCommandId(IM::BaseDefine::CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE);
    CProxyConn::AddResponsePdu(conn_uuid, pPduResp);
  }
  else
  {
    log("parse pb failed");
  }
}

/**
 *  删除会话接口(单个会话)
 *
 *  @param pPdu      收到的packet包指针
 *  @param conn_uuid 该包过来的socket 描述符
 */
void deleteRecentSession(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Buddy::IMRemoveSessionReq msg;
  IM::Buddy::IMRemoveSessionRsp msgResp;

  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    CImPdu* pPduResp = new CImPdu;

    uint32_t nUserId = msg.user_id();
    uint32_t nPeerId = msg.session_id();
    IM::BaseDefine::SessionType nType = msg.session_type();
    if(IM::BaseDefine::SessionType_IsValid(nType))
    {
      bool bRet = false;
      uint32_t nSessionId = CSessionModel::getInstance()->getSessionId(nUserId, nPeerId, nType, false);
      if (nSessionId != INVALID_VALUE) {
        bRet = CSessionModel::getInstance()->removeSession(nSessionId);
        // if remove session success, we need to clear the unread msg count
        if (bRet)
        {
          //删除用户聊天记录
          CUserModel::getInstance()->clearUserCounter(nUserId, nPeerId, nType);
        }
      }
      log("userId=%d, peerId=%d, result=%s", nUserId, nPeerId, bRet?"success":"failed");

      msgResp.set_attach_data(msg.attach_data());
      msgResp.set_user_id(nUserId);
      msgResp.set_session_id(nPeerId);
      msgResp.set_session_type(nType);
      msgResp.set_result_code(bRet?0:1);
      pPduResp->SetPBMsg(&msgResp);
      pPduResp->SetSeqNum(pPdu->GetSeqNum());
      pPduResp->SetServiceId(IM::BaseDefine::SID_BUDDY_LIST);
      pPduResp->SetCommandId(IM::BaseDefine::CID_BUDDY_LIST_REMOVE_SESSION_RES);
      CProxyConn::AddResponsePdu(conn_uuid, pPduResp);
    }
    else
    {
      log("invalied session_type. userId=%u, peerId=%u, seseionType=%u", nUserId, nPeerId, nType);
    }
  }
  else{
    log("parse pb failed");
  }
}

};

/* db_proxy_server - business - RelationModel.h */
#ifndef RELATION_SHIP_H_
#define RELATION_SHIP_H_

#include <list>

#include "util.h"
#include "ImPduBase.h"
#include "IM.BaseDefine.pb.h"

using namespace std;

/* getRelationId 获取用户关系id. (即用户与用户之间的会话关系, 用户与群组之间的会话关系)
 * updateRelation 更新用户关系.
 * removeRelation 删除用户关系.
 * addRelation 添加用户关系.
 */
class CRelationModel {
public:
  virtual ~CRelationModel();

  static CRelationModel* getInstance();
  uint32_t getRelationId(uint32_t nUserAId, uint32_t nUserBId, bool bAdd);
  bool updateRelation(uint32_t nRelationId, uint32_t nUpdateTime);
  bool removeRelation(uint32_t nRelationId);

private:
  CRelationModel();
  uint32_t addRelation(uint32_t nSmallId, uint32_t nBigId);

private:
  static CRelationModel*	m_pInstance;
};

#endif

/* db_proxy_server - business - RelationModel.h */
#include <vector>
#include "../DBPool.h"
#include "RelationModel.h"
#include "MessageModel.h"
#include "GroupMessageModel.h"
using namespace std;

CRelationModel* CRelationModel::m_pInstance = NULL;

CRelationModel::CRelationModel()
{

}

CRelationModel::~CRelationModel()
{

}

CRelationModel* CRelationModel::getInstance()
{
  if (!m_pInstance) {
    m_pInstance = new CRelationModel();
  }

  return m_pInstance;
}

/* 获取用户关系id. (即用户与用户之间的关系, 用户与群组之间的关系)
 * 如果查询不到该id, 则说明该关系是新增的,调用addRelation添加用户关系
 */
uint32_t CRelationModel::getRelationId(uint32_t nUserAId, uint32_t nUserBId, bool bAdd)
{
  uint32_t nRelationId = INVALID_VALUE;
  if (nUserAId == 0 || nUserBId == 0) {
    log("invalied user id:%u->%u", nUserAId, nUserBId);
    return nRelationId;
  }
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  if (pDBConn)
  {
    uint32_t nBigId = nUserAId > nUserBId ? nUserAId : nUserBId;
    uint32_t nSmallId = nUserAId > nUserBId ? nUserBId : nUserAId;
    string strSql = "select id from IMRelationShip where smallId=" + int2string(nSmallId) + " and bigId="+ int2string(nBigId) + " and status = 0";

    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if (pResultSet)
    {
      while (pResultSet->Next())
      {
        nRelationId = pResultSet->GetInt("id");
      }
      delete pResultSet;
    }
    else
    {
      log("there is no result for sql:%s", strSql.c_str());
    }
    pDBManager->RelDBConn(pDBConn);
    if (nRelationId == INVALID_VALUE && bAdd)
    {
      nRelationId = addRelation(nSmallId, nBigId);
    }
  }
  else
  {
    log("no db connection for teamtalk_slave");
  }
  return nRelationId;
}

/* 添加用户关系.
 * 如果sql语句能查询到该会话id记录,则更新该记录status状态
 * 否则插入一条新记录,表示增加新的关系记录.
 */
uint32_t CRelationModel::addRelation(uint32_t nSmallId, uint32_t nBigId)
{
  uint32_t nRelationId = INVALID_VALUE;
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if (pDBConn)
  {
    uint32_t nTimeNow = (uint32_t)time(NULL);
    string strSql = "select id from IMRelationShip where smallId=" + int2string(nSmallId) + " and bigId="+ int2string(nBigId);
    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if(pResultSet && pResultSet->Next())
    {
      nRelationId = pResultSet->GetInt("id");
      strSql = "update IMRelationShip set status=0, updated=" + int2string(nTimeNow) + " where id=" + int2string(nRelationId);
      bool bRet = pDBConn->ExecuteUpdate(strSql.c_str());
      if(!bRet)
      {
        nRelationId = INVALID_VALUE;
      }
      log("has relation ship set status");
      delete pResultSet;
    }
    else
    {
      strSql = "insert into IMRelationShip (`smallId`,`bigId`,`status`,`created`,`updated`) values(?,?,?,?,?)";
      // 必须在释放连接前delete CPrepareStatement对象，否则有可能多个线程操作mysql对象，会crash
      CPrepareStatement* stmt = new CPrepareStatement();
      if (stmt->Init(pDBConn->GetMysql(), strSql))
      {
        uint32_t nStatus = 0;
        uint32_t index = 0;
        stmt->SetParam(index++, nSmallId);
        stmt->SetParam(index++, nBigId);
        stmt->SetParam(index++, nStatus);
        stmt->SetParam(index++, nTimeNow);
        stmt->SetParam(index++, nTimeNow);
        bool bRet = stmt->ExecuteUpdate();
        if (bRet)
        {
          nRelationId = pDBConn->GetInsertId();
        }
        else
        {
          log("insert message failed. %s", strSql.c_str());
        }
      }
      if(nRelationId != INVALID_VALUE)
      {
        // 初始化msgId
        if(!CMessageModel::getInstance()->resetMsgId(nRelationId))
        {
          log("reset msgId failed. smallId=%u, bigId=%u.", nSmallId, nBigId);
        }
      }
      delete stmt;
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
  return nRelationId;
}
  
/* 更新用户关系(更新时间).*/
bool CRelationModel::updateRelation(uint32_t nRelationId, uint32_t nUpdateTime)
{
  bool bRet = false;
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if (pDBConn)
  {
    string strSql = "update IMRelationShip set `updated`="+int2string(nUpdateTime) + " where id="+int2string(nRelationId);
    bRet = pDBConn->ExecuteUpdate(strSql.c_str());
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
  return bRet;
}

/* 删除用户关系.(更新status状态) */
bool CRelationModel::removeRelation(uint32_t nRelationId)
{
  bool bRet = false;
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if (pDBConn)
  {
    uint32_t nNow = (uint32_t) time(NULL);
    string strSql = "update IMRelationShip set status = 1, updated="+int2string(nNow)+" where id=" + int2string(nRelationId);
    bRet = pDBConn->ExecuteUpdate(strSql.c_str());
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
  return bRet;
}

/* db_proxy_server - business - MessageModel.h */
#ifndef MESSAGE_MODEL_H_
#define MESSAGE_MODEL_H_

#include <list>
#include <string>
#include "util.h"
#include "ImPduBase.h"
#include "AudioModel.h"
#include "IM.BaseDefine.pb.h"
using namespace std;

/* @param IMMessage_x 消息表, x是分表的序号,记录用户发送的每条消息,每条消息都有唯一的消息id,消息id的自增长的.
 * @param nRelateId 用户关系id, 作用:确认用户与用户之间, 用户与群组之间的唯一关系. nRelateId%8 用于消息表分表.
 * @param nMsgId 消息id, 作用:每发送一条消息都会在消息表产生一条消息记录
 *
 * getMessage 获取消息
 * sendMessage 发送消息.
 * sendAudioMessage 发送语音消息.
 * incMsgCount 增加消息数.
 * getUnreadMsgCount 获取未读消息记录.
 * getMsgId 获取消息id.
 * getLastMsg 获取最近一条消息.
 * getUnReadCntAll 获取未读消息总数.
 * getMsgByMsgId 通过消息id(多条)获取消息(多条)
 * resetMsgId 重置消息id
 */
class CMessageModel {
public:
  virtual ~CMessageModel();
  static CMessageModel* getInstance();

  bool sendMessage(uint32_t nRelateId, uint32_t nFromId, uint32_t nToId, IM::BaseDefine::MsgType nMsgType, uint32_t nCreateTime,
                   uint32_t nMsgId, string& strMsgContent);
  bool sendAudioMessage(uint32_t nRelateId, uint32_t nFromId, uint32_t nToId, IM::BaseDefine::MsgType nMsgType, uint32_t nCreateTime,
                        uint32_t nMsgId, const char* pMsgContent, uint32_t nMsgLen);
  void getMessage(uint32_t nUserId, uint32_t nPeerId, uint32_t nMsgId, uint32_t nMsgCnt, list<IM::BaseDefine::MsgInfo>& lsMsg);
  bool clearMessageCount(uint32_t nUserId, uint32_t nPeerId);
  uint32_t getMsgId(uint32_t nRelateId);
  void getUnreadMsgCount(uint32_t nUserId, uint32_t &nTotalCnt, list<IM::BaseDefine::UnreadInfo>& lsUnreadCount);
  void getLastMsg(uint32_t nFromId, uint32_t nToId, uint32_t& nMsgId, string& strMsgData, IM::BaseDefine::MsgType & nMsgType, uint32_t nStatus = 0);
  void getUnReadCntAll(uint32_t nUserId, uint32_t &nTotalCnt);
  void getMsgByMsgId(uint32_t nUserId, uint32_t nPeerId, const list<uint32_t>& lsMsgId, list<IM::BaseDefine::MsgInfo>& lsMsg);
  bool resetMsgId(uint32_t nRelateId);
private:
  CMessageModel();
  void incMsgCount(uint32_t nFromId, uint32_t nToId);
private:
  static CMessageModel*	m_pInstance;
};

#endif /* MESSAGE_MODEL_H_ */

/* db_proxy_server - business - MessageModel.cpp */
#include <map>
#include <set>
#include "../DBPool.h"
#include "../CachePool.h"
#include "MessageModel.h"
#include "AudioModel.h"
#include "SessionModel.h"
#include "RelationModel.h"

using namespace std;

CMessageModel* CMessageModel::m_pInstance = NULL;
extern string strAudioEnc;

CMessageModel::CMessageModel()
{

}

CMessageModel::~CMessageModel()
{

}

CMessageModel* CMessageModel::getInstance()
{
  if (!m_pInstance) {
    m_pInstance = new CMessageModel();
  }

  return m_pInstance;
}

/* 获取消息(获取用户nUserId与用户nPeerId最近nMsgCnt条消息). */
void CMessageModel::getMessage(uint32_t nUserId, uint32_t nPeerId, uint32_t nMsgId, uint32_t nMsgCnt, list<IM::BaseDefine::MsgInfo>& lsMsg)
{
  uint32_t nRelateId = CRelationModel::getInstance()->getRelationId(nUserId, nPeerId, false);
  if (nRelateId != INVALID_VALUE)
  {
    CDBManager* pDBManager = CDBManager::getInstance();
    CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
    if (pDBConn)
    {
      string strTableName = "IMMessage_" + int2string(nRelateId % 8);
      string strSql;
      if (nMsgId == 0) {
        strSql = "select * from " + strTableName + " force index (idx_relateId_status_created) where relateId= " + int2string(nRelateId) + " and status = 0 order by created desc, id desc limit " + int2string(nMsgCnt);
      }
      else
      {
        strSql = "select * from " + strTableName + " force index (idx_relateId_status_created) where relateId= " + int2string(nRelateId) + " and status = 0 and msgId <=" + int2string(nMsgId)+ " order by created desc, id desc limit " + int2string(nMsgCnt);
      }
      CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
      if (pResultSet)
      {
        while (pResultSet->Next())
        {
          IM::BaseDefine::MsgInfo cMsg;
          cMsg.set_msg_id(pResultSet->GetInt("msgId"));
          cMsg.set_from_session_id(pResultSet->GetInt("fromId"));
          cMsg.set_create_time(pResultSet->GetInt("created"));
          IM::BaseDefine::MsgType nMsgType = IM::BaseDefine::MsgType(pResultSet->GetInt("type"));
          if(IM::BaseDefine::MsgType_IsValid(nMsgType))
          {
            cMsg.set_msg_type(nMsgType);
            cMsg.set_msg_data(pResultSet->GetString("content"));
            lsMsg.push_back(cMsg);
          }
          else
          {
            log("invalid msgType. userId=%u, peerId=%u, msgId=%u, msgCnt=%u, msgType=%u", nUserId, nPeerId, nMsgId, nMsgCnt, nMsgType);
          }
        }
        delete pResultSet;
      }
      else
      {
        log("no result set: %s", strSql.c_str());
      }
      pDBManager->RelDBConn(pDBConn);
      if (!lsMsg.empty())
      {
        CAudioModel::getInstance()->readAudios(lsMsg);
      }
    }
    else
    {
      log("no db connection for teamtalk_slave");
    }
  }
  else
  {
    log("no relation between %lu and %lu", nUserId, nPeerId);
  }
}

/* 发送消息. */
bool CMessageModel::sendMessage(uint32_t nRelateId, uint32_t nFromId, uint32_t nToId, IM::BaseDefine::MsgType nMsgType, uint32_t nCreateTime, uint32_t nMsgId, string& strMsgContent)
{
  bool bRet =false;
  if (nFromId == 0 || nToId == 0) {
    log("invalied userId.%u->%u", nFromId, nToId);
    return bRet;
  }

  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if (pDBConn)
  {
    string strTableName = "IMMessage_" + int2string(nRelateId % 8);
    string strSql = "insert into " + strTableName + " (`relateId`, `fromId`, `toId`, `msgId`, `content`, `status`, `type`, `created`, `updated`) values(?, ?, ?, ?, ?, ?, ?, ?, ?)";
    // 必须在释放连接前delete CPrepareStatement对象，否则有可能多个线程操作mysql对象，会crash
    CPrepareStatement* pStmt = new CPrepareStatement();
    if (pStmt->Init(pDBConn->GetMysql(), strSql))
    {
      uint32_t nStatus = 0;
      uint32_t nType = nMsgType;
      uint32_t index = 0;
      pStmt->SetParam(index++, nRelateId);
      pStmt->SetParam(index++, nFromId);
      pStmt->SetParam(index++, nToId);
      pStmt->SetParam(index++, nMsgId);
      pStmt->SetParam(index++, strMsgContent);
      pStmt->SetParam(index++, nStatus);
      pStmt->SetParam(index++, nType);
      pStmt->SetParam(index++, nCreateTime);
      pStmt->SetParam(index++, nCreateTime);
      bRet = pStmt->ExecuteUpdate();
    }
    delete pStmt;
    pDBManager->RelDBConn(pDBConn);
    if (bRet)
    {
      uint32_t nNow = (uint32_t) time(NULL);
      incMsgCount(nFromId, nToId);
    }
    else
    {
      log("insert message failed: %s", strSql.c_str());
    }
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
  return bRet;
}

/* 发送语音消息. */
bool CMessageModel::sendAudioMessage(uint32_t nRelateId, uint32_t nFromId, uint32_t nToId, IM::BaseDefine::MsgType nMsgType, uint32_t nCreateTime, uint32_t nMsgId, const char* pMsgContent, uint32_t nMsgLen)
{
  if (nMsgLen <= 4) {
    return false;
  }

  CAudioModel* pAudioModel = CAudioModel::getInstance();
  int nAudioId = pAudioModel->saveAudioInfo(nFromId, nToId, nCreateTime, pMsgContent, nMsgLen);

  bool bRet = true;
  if (nAudioId != -1) {
    string strMsg = int2string(nAudioId);
    bRet = sendMessage(nRelateId, nFromId, nToId, nMsgType, nCreateTime, nMsgId, strMsg);
  } else {
    bRet = false;
  }

  return bRet;
}

/* 增加消息数(增加发送方与接收方的消息数). */
void CMessageModel::incMsgCount(uint32_t nFromId, uint32_t nToId)
{
  CacheManager* pCacheManager = CacheManager::getInstance();
  // increase message count
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
  if (pCacheConn) {
    pCacheConn->hincrBy("unread_" + int2string(nToId), int2string(nFromId), 1);
    pCacheManager->RelCacheConn(pCacheConn);
  } else {
    log("no cache connection to increase unread count: %d->%d", nFromId, nToId);
  }
}

/* 获取未读消息记录. */
void CMessageModel::getUnreadMsgCount(uint32_t nUserId, uint32_t &nTotalCnt, list<IM::BaseDefine::UnreadInfo>& lsUnreadCount)
{
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
  if (pCacheConn)
  {
    map<string, string> mapUnread;
    string strKey = "unread_" + int2string(nUserId);
    bool bRet = pCacheConn->hgetAll(strKey, mapUnread);
    pCacheManager->RelCacheConn(pCacheConn);
    if(bRet)
    {
      IM::BaseDefine::UnreadInfo cUnreadInfo;
      for (auto it = mapUnread.begin(); it != mapUnread.end(); it++) {
        cUnreadInfo.set_session_id(atoi(it->first.c_str()));
        cUnreadInfo.set_unread_cnt(atoi(it->second.c_str()));
        cUnreadInfo.set_session_type(IM::BaseDefine::SESSION_TYPE_SINGLE);
        uint32_t nMsgId = 0;
        string strMsgData;
        IM::BaseDefine::MsgType nMsgType;
        getLastMsg(cUnreadInfo.session_id(), nUserId, nMsgId, strMsgData, nMsgType);
        if(IM::BaseDefine::MsgType_IsValid(nMsgType))
        {
          cUnreadInfo.set_latest_msg_id(nMsgId);
          cUnreadInfo.set_latest_msg_data(strMsgData);
          cUnreadInfo.set_latest_msg_type(nMsgType);
          cUnreadInfo.set_latest_msg_from_user_id(cUnreadInfo.session_id());
          lsUnreadCount.push_back(cUnreadInfo);
          nTotalCnt += cUnreadInfo.unread_cnt();
        }
        else
        {
          log("invalid msgType. userId=%u, peerId=%u, msgType=%u", nUserId, cUnreadInfo.session_id(), nMsgType);
        }
      }
    }
    else
    {
      log("hgetall %s failed!", strKey.c_str());
    }
  }
  else
  {
    log("no cache connection for unread");
  }
}

/* 获取消息id. */
uint32_t CMessageModel::getMsgId(uint32_t nRelateId)
{
  uint32_t nMsgId = 0;
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
  if(pCacheConn)
  {
    string strKey = "msg_id_" + int2string(nRelateId);
    nMsgId = pCacheConn->incrBy(strKey, 1);
    pCacheManager->RelCacheConn(pCacheConn);
  }
  return nMsgId;
}

/* 获取最近一条消息. */
void CMessageModel::getLastMsg(uint32_t nFromId, uint32_t nToId, uint32_t& nMsgId, string& strMsgData, IM::BaseDefine::MsgType& nMsgType, uint32_t nStatus)
{
  uint32_t nRelateId = CRelationModel::getInstance()->getRelationId(nFromId, nToId, false);

  if (nRelateId != INVALID_VALUE)
  {

    CDBManager* pDBManager = CDBManager::getInstance();
    CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
    if (pDBConn)
    {
      string strTableName = "IMMessage_" + int2string(nRelateId % 8);
      string strSql = "select msgId,type,content from " + strTableName + " force index (idx_relateId_status_created) where relateId= " + int2string(nRelateId) + " and status = 0 order by created desc, id desc limit 1";
      CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
      if (pResultSet)
      {
        while (pResultSet->Next())
        {
          nMsgId = pResultSet->GetInt("msgId");

          nMsgType = IM::BaseDefine::MsgType(pResultSet->GetInt("type"));
          if (nMsgType == IM::BaseDefine::MSG_TYPE_SINGLE_AUDIO)
          {
            // "[语音]"加密后的字符串
            strMsgData = strAudioEnc;
          }
          else
          {
            strMsgData = pResultSet->GetString("content");
          }
        }
        delete pResultSet;
      }
      else
      {
        log("no result set: %s", strSql.c_str());
      }
      pDBManager->RelDBConn(pDBConn);
    }
    else
    {
      log("no db connection_slave");
    }
  }
  else
  {
    log("no relation between %lu and %lu", nFromId, nToId);
  }
}

/* 获取未读消息总数. */
void CMessageModel::getUnReadCntAll(uint32_t nUserId, uint32_t &nTotalCnt)
{
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
  if (pCacheConn)
  {
    map<string, string> mapUnread;
    string strKey = "unread_" + int2string(nUserId);
    bool bRet = pCacheConn->hgetAll(strKey, mapUnread);
    pCacheManager->RelCacheConn(pCacheConn);

    if(bRet)
    {
      for (auto it = mapUnread.begin(); it != mapUnread.end(); it++) {
        nTotalCnt += atoi(it->second.c_str());
      }
    }
    else
    {
      log("hgetall %s failed!", strKey.c_str());
    }
  }
  else
  {
    log("no cache connection for unread");
  }
}

/* 通过消息id(多条)获取消息(多条) */
void CMessageModel::getMsgByMsgId(uint32_t nUserId, uint32_t nPeerId, const list<uint32_t> &lsMsgId, list<IM::BaseDefine::MsgInfo> &lsMsg)
{
  if(lsMsgId.empty())

  {
    return ;
  }
  uint32_t nRelateId = CRelationModel::getInstance()->getRelationId(nUserId, nPeerId, false);

  if(nRelateId == INVALID_VALUE)
  {
    log("invalid relation id between %u and %u", nUserId, nPeerId);
    return;
  }

  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  if (pDBConn)
  {
    string strTableName = "IMMessage_" + int2string(nRelateId % 8);
    string strClause ;
    bool bFirst = true;
    for(auto it= lsMsgId.begin(); it!=lsMsgId.end();++it)
    {
      if (bFirst) {
        bFirst = false;
        strClause = int2string(*it);
      }
      else
      {
        strClause += ("," + int2string(*it));
      }
    }

    string strSql = "select * from " + strTableName + " where relateId=" + int2string(nRelateId) + "  and status=0 and msgId in (" + strClause + ") order by created desc, id desc limit 100";
    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if (pResultSet)
    {
      while (pResultSet->Next())
      {
        IM::BaseDefine::MsgInfo msg;
        msg.set_msg_id(pResultSet->GetInt("msgId"));
        msg.set_from_session_id(pResultSet->GetInt("fromId"));
        msg.set_create_time(pResultSet->GetInt("created"));
        IM::BaseDefine::MsgType nMsgType = IM::BaseDefine::MsgType(pResultSet->GetInt("type"));
        if(IM::BaseDefine::MsgType_IsValid(nMsgType))
        {
          msg.set_msg_type(nMsgType);
          msg.set_msg_data(pResultSet->GetString("content"));
          lsMsg.push_back(msg);
        }
        else
        {
          log("invalid msgType. userId=%u, peerId=%u, msgType=%u, msgId=%u", nUserId, nPeerId, nMsgType, msg.msg_id());
        }
      }
      delete pResultSet;
    }
    else
    {
      log("no result set for sql:%s", strSql.c_str());
    }
    pDBManager->RelDBConn(pDBConn);
    if(!lsMsg.empty())
    {
      CAudioModel::getInstance()->readAudios(lsMsg);
    }
  }
  else
  {
    log("no db connection for teamtalk_slave");
  }
}

/* 重置消息id */
bool CMessageModel::resetMsgId(uint32_t nRelateId)
{
  bool bRet = false;
  uint32_t nMsgId = 0;
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
  if(pCacheConn)
  {
    string strKey = "msg_id_" + int2string(nRelateId);
    string strValue = "0";
    string strReply = pCacheConn->set(strKey, strValue);
    if(strReply == strValue)
    {
      bRet = true;
    }
    pCacheManager->RelCacheConn(pCacheConn);
  }
  return bRet;
}

/* db_proxy_server - business - GroupMessageModel.h */
#ifndef GROUP_MESSAGE_MODEL_H_
#define GROUP_MESSAGE_MODEL_H_

#include <list>
#include <string>

#include "util.h"
#include "ImPduBase.h"
#include "AudioModel.h"
#include "GroupModel.h"
#include "IM.BaseDefine.pb.h"

using namespace std;

class CGroupMessageModel {
public:
  virtual ~CGroupMessageModel();
  static CGroupMessageModel* getInstance();

  bool sendMessage(uint32_t nFromId, uint32_t nGroupId, IM::BaseDefine::MsgType nMsgType, uint32_t nCreateTime, uint32_t nMsgId, const string& strMsgContent);
  bool sendAudioMessage(uint32_t nFromId, uint32_t nGroupId, IM::BaseDefine::MsgType nMsgType, uint32_t nCreateTime, uint32_t nMsgId,const char* pMsgContent, uint32_t nMsgLen);
  void getMessage(uint32_t nUserId, uint32_t nGroupId, uint32_t nMsgId, uint32_t nMsgCnt, list<IM::BaseDefine::MsgInfo>& lsMsg);
  bool clearMessageCount(uint32_t nUserId, uint32_t nGroupId);
  uint32_t getMsgId(uint32_t nGroupId);
  void getUnreadMsgCount(uint32_t nUserId, uint32_t &nTotalCnt, list<IM::BaseDefine::UnreadInfo>& lsUnreadCount);
  void getLastMsg(uint32_t nGroupId, uint32_t& nMsgId, string& strMsgData, IM::BaseDefine::MsgType & nMsgType, uint32_t& nFromId);
  void getUnReadCntAll(uint32_t nUserId, uint32_t &nTotalCnt);
  void getMsgByMsgId(uint32_t nUserId, uint32_t nGroupId, const list<uint32_t>& lsMsgId, list<IM::BaseDefine::MsgInfo>& lsMsg);
  bool resetMsgId(uint32_t nGroupId);
private:
  CGroupMessageModel();
  bool incMessageCount(uint32_t nUserId, uint32_t nGroupId);

private:
  static CGroupMessageModel*	m_pInstance;
};

#endif /* MESSAGE_MODEL_H_ */

/* db_proxy_server - business - GroupMessageModel.cpp */
#include <map>
#include <set>
#include "../DBPool.h"
#include "../CachePool.h"
#include "GroupMessageModel.h"
#include "AudioModel.h"
#include "SessionModel.h"
#include "MessageCounter.h"
#include "Common.h"
#include "GroupModel.h"

using namespace std;

extern string strAudioEnc;

CGroupMessageModel* CGroupMessageModel::m_pInstance = NULL;

/**
 *  构造函数
 */
CGroupMessageModel::CGroupMessageModel()
{

}

/**
 *  析构函数
 */
CGroupMessageModel::~CGroupMessageModel()
{

}

/**
 *  单例
 *
 *  @return 返回单例指针
 */
CGroupMessageModel* CGroupMessageModel::getInstance()
{
  if (!m_pInstance) {
    m_pInstance = new CGroupMessageModel();
  }

  return m_pInstance;
}

/**
 *  发送群消息接口
 *
 *  @param nRelateId     关系Id
 *  @param nFromId       发送者Id
 *  @param nGroupId      群组Id
 *  @param nMsgType      消息类型
 *  @param nCreateTime   消息创建时间
 *  @param nMsgId        消息Id
 *  @param strMsgContent 消息类容
 *
 *  @return 成功返回true 失败返回false
 */
bool CGroupMessageModel::sendMessage(uint32_t nFromId, uint32_t nGroupId, IM::BaseDefine::MsgType nMsgType, uint32_t nCreateTime,uint32_t nMsgId, const string& strMsgContent)
{
  bool bRet = false;
  if(CGroupModel::getInstance()->isInGroup(nFromId, nGroupId))
  {
    CDBManager* pDBManager = CDBManager::getInstance();
    CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
    if (pDBConn)
    {
      string strTableName = "IMGroupMessage_" + int2string(nGroupId % 8);
      string strSql = "insert into " + strTableName + " (`groupId`, `userId`, `msgId`, `content`, `type`, `status`, `updated`, `created`) "\
                       "values(?, ?, ?, ?, ?, ?, ?, ?)";

      // 必须在释放连接前delete CPrepareStatement对象，否则有可能多个线程操作mysql对象，会crash
      CPrepareStatement* pStmt = new CPrepareStatement();
      if (pStmt->Init(pDBConn->GetMysql(), strSql))
      {
        uint32_t nStatus = 0;
        uint32_t nType = nMsgType;
        uint32_t index = 0;
        pStmt->SetParam(index++, nGroupId);
        pStmt->SetParam(index++, nFromId);
        pStmt->SetParam(index++, nMsgId);
        pStmt->SetParam(index++, strMsgContent);
        pStmt->SetParam(index++, nType);
        pStmt->SetParam(index++, nStatus);
        pStmt->SetParam(index++, nCreateTime);
        pStmt->SetParam(index++, nCreateTime);

        bool bRet = pStmt->ExecuteUpdate();
        if (bRet)
        {
          CGroupModel::getInstance()->updateGroupChat(nGroupId);
          incMessageCount(nFromId, nGroupId);
          //clearMessageCount(nFromId, nGroupId);
        } else {
          log("insert message failed: %s", strSql.c_str());
        }
      }
      delete pStmt;
      pDBManager->RelDBConn(pDBConn);
    }
    else
    {
      log("no db connection for teamtalk_master");
    }
  }
  else
  {
    log("not in the group.fromId=%u, groupId=%u", nFromId, nGroupId);
  }
  return bRet;
}

/**
 *  发送群组语音信息
 *
 *  @param nRelateId   关系Id
 *  @param nFromId     发送者Id
 *  @param nGroupId    群组Id
 *  @param nMsgType    消息类型
 *  @param nCreateTime 消息创建时间
 *  @param nMsgId      消息Id
 *  @param pMsgContent 指向语音类容的指针
 *  @param nMsgLen     语音消息长度
 *
 *  @return 成功返回true，失败返回false
 */
bool CGroupMessageModel::sendAudioMessage(uint32_t nFromId, uint32_t nGroupId, IM::BaseDefine::MsgType nMsgType, uint32_t nCreateTime, uint32_t nMsgId, const char* pMsgContent, uint32_t nMsgLen)
{
  if (nMsgLen <= 4) {
    return false;
  }

  if(!CGroupModel::getInstance()->isInGroup(nFromId, nGroupId))
  {
    log("not in the group.fromId=%u, groupId=%u", nFromId, nGroupId);
    return false;
  }

  CAudioModel* pAudioModel = CAudioModel::getInstance();
  int nAudioId = pAudioModel->saveAudioInfo(nFromId, nGroupId, nCreateTime, pMsgContent, nMsgLen);

  bool bRet = true;
  if (nAudioId != -1) {
    string strMsg = int2string(nAudioId);
    bRet = sendMessage(nFromId, nGroupId, nMsgType, nCreateTime, nMsgId, strMsg);
  } else {
    bRet = false;
  }

  return bRet;
}

/**
 *  清除群组消息计数 (fixme)
 *
 *  @param nUserId  用户Id
 *  @param nGroupId 群组Id
 *
 *  @return 成功返回true，失败返回false
 */
bool CGroupMessageModel::clearMessageCount(uint32_t nUserId, uint32_t nGroupId)
{
  bool bRet = false;
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
  if (pCacheConn)
  {
    string strGroupKey = int2string(nGroupId) + GROUP_TOTAL_MSG_COUNTER_REDIS_KEY_SUFFIX;
    map<string, string> mapGroupCount;
    bool bRet = pCacheConn->hgetAll(strGroupKey, mapGroupCount);
    if(bRet)
    {
      string strUserKey = int2string(nUserId) + "_" + int2string(nGroupId) + GROUP_USER_MSG_COUNTER_REDIS_KEY_SUFFIX;
      string strReply = pCacheConn->hmset(strUserKey, mapGroupCount);
      if(strReply.empty())
      {
        log("hmset %s failed !", strUserKey.c_str());
      }
      else
      {
        bRet = true;
      }
    }
    else
    {
      log("hgetAll %s failed !", strGroupKey.c_str());
    }
    pCacheManager->RelCacheConn(pCacheConn);
  }
  else
  {
    log("no cache connection for unread");
  }
  return bRet;
}

/**
 *  增加群消息计数
 *
 *  @param nUserId  用户Id
 *  @param nGroupId 群组Id
 *
 *  @return 成功返回true，失败返回false
 */
bool CGroupMessageModel::incMessageCount(uint32_t nUserId, uint32_t nGroupId)
{
  bool bRet = false;
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
  if (pCacheConn)
  {
    string strGroupKey = int2string(nGroupId) + GROUP_TOTAL_MSG_COUNTER_REDIS_KEY_SUFFIX;
    pCacheConn->hincrBy(strGroupKey, GROUP_COUNTER_SUBKEY_COUNTER_FIELD, 1);
    map<string, string> mapGroupCount;
    bool bRet = pCacheConn->hgetAll(strGroupKey, mapGroupCount);
    if(bRet)
    {
      string strUserKey = int2string(nUserId) + "_" + int2string(nGroupId) + GROUP_USER_MSG_COUNTER_REDIS_KEY_SUFFIX;
      string strReply = pCacheConn->hmset(strUserKey, mapGroupCount);
      if(!strReply.empty())
      {
        bRet = true;
      }
      else
      {
        log("hmset %s failed !", strUserKey.c_str());
      }
    }
    else
    {
      log("hgetAll %s failed!", strGroupKey.c_str());
    }
    pCacheManager->RelCacheConn(pCacheConn);
  }
  else
  {
    log("no cache connection for unread");
  }
  return bRet;
}

/**
 *  获取群组消息列表
 *
 *  @param nUserId  用户Id
 *  @param nGroupId 群组Id
 *  @param nMsgId   开始的msgId(最新的msgId)
 *  @param nMsgCnt  获取的长度
 *  @param lsMsg    消息列表
 */
void CGroupMessageModel::getMessage(uint32_t nUserId, uint32_t nGroupId, uint32_t nMsgId, uint32_t nMsgCnt, list<IM::BaseDefine::MsgInfo>& lsMsg)
{
  //根据 count 和 lastId 获取信息
  string strTableName = "IMGroupMessage_" + int2string(nGroupId % 8);

  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  if (pDBConn)
  {
    uint32_t nUpdated = CGroupModel::getInstance()->getUserJoinTime(nGroupId, nUserId);
    //如果nMsgId 为0 表示客户端想拉取最新的nMsgCnt条消息
    string strSql;
    if(nMsgId == 0)
    {
      strSql = "select * from " + strTableName + " where groupId = " + int2string(nGroupId) + " and status = 0 and created>="+ int2string(nUpdated) + " order by created desc, id desc limit " + int2string(nMsgCnt);
    }else {
      strSql = "select * from " + strTableName + " where groupId = " + int2string(nGroupId) + " and msgId<=" + int2string(nMsgId) + " and status = 0 and created>="+ int2string(nUpdated) + " order by created desc, id desc limit " + int2string(nMsgCnt);
    }

    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if (pResultSet)
    {
      map<uint32_t, IM::BaseDefine::MsgInfo> mapAudioMsg;
      while(pResultSet->Next())
      {
        IM::BaseDefine::MsgInfo msg;
        msg.set_msg_id(pResultSet->GetInt("msgId"));
        msg.set_from_session_id(pResultSet->GetInt("userId"));
        msg.set_create_time(pResultSet->GetInt("created"));
        IM::BaseDefine::MsgType nMsgType = IM::BaseDefine::MsgType(pResultSet->GetInt("type"));
        if(IM::BaseDefine::MsgType_IsValid(nMsgType))
        {
          msg.set_msg_type(nMsgType);
          msg.set_msg_data(pResultSet->GetString("content"));
          lsMsg.push_back(msg);
        }
        else
        {
          log("invalid msgType. userId=%u, groupId=%u, msgType=%u", nUserId, nGroupId, nMsgType);
        }
      }
      delete pResultSet;
    }
    else
    {
      log("no result set for sql: %s", strSql.c_str());
    }
    pDBManager->RelDBConn(pDBConn);
    if (!lsMsg.empty()) {
      CAudioModel::getInstance()->readAudios(lsMsg);
    }
  }
  else
  {
    log("no db connection for teamtalk_slave");
  }
}

/**
 *  获取用户群未读消息计数
 *
 *  @param nUserId       用户Id
 *  @param nTotalCnt     总条数
 *  @param lsUnreadCount 每个会话的未读信息包含了条数，最后一个消息的Id，最后一个消息的类型，最后一个消息的类容
 */
void CGroupMessageModel::getUnreadMsgCount(uint32_t nUserId, uint32_t &nTotalCnt, list<IM::BaseDefine::UnreadInfo>& lsUnreadCount)
{
  list<uint32_t> lsGroupId;
  CGroupModel::getInstance()->getUserGroupIds(nUserId, lsGroupId, 0);
  uint32_t nCount = 0;

  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
  if (pCacheConn)
  {
    for(auto it=lsGroupId.begin(); it!=lsGroupId.end(); ++it)
    {
      uint32_t nGroupId = *it;
      string strGroupKey = int2string(nGroupId) + GROUP_TOTAL_MSG_COUNTER_REDIS_KEY_SUFFIX;
      string strGroupCnt = pCacheConn->hget(strGroupKey, GROUP_COUNTER_SUBKEY_COUNTER_FIELD);
      if(strGroupCnt.empty())
      {
        //                log("hget %s : count failed !", strGroupKey.c_str());
        continue;
      }
      uint32_t nGroupCnt = (uint32_t)(atoi(strGroupCnt.c_str()));

      string strUserKey = int2string(nUserId) + "_" + int2string(nGroupId) + GROUP_USER_MSG_COUNTER_REDIS_KEY_SUFFIX;
      string strUserCnt = pCacheConn->hget(strUserKey, GROUP_COUNTER_SUBKEY_COUNTER_FIELD);

      uint32_t nUserCnt = ( strUserCnt.empty() ? 0 : ((uint32_t)atoi(strUserCnt.c_str())) );
      if(nGroupCnt >= nUserCnt) {
        nCount = nGroupCnt - nUserCnt;
      }
      if(nCount > 0)
      {
        IM::BaseDefine::UnreadInfo cUnreadInfo;
        cUnreadInfo.set_session_id(nGroupId);
        cUnreadInfo.set_session_type(IM::BaseDefine::SESSION_TYPE_GROUP);
        cUnreadInfo.set_unread_cnt(nCount);
        nTotalCnt += nCount;
        string strMsgData;
        uint32_t nMsgId;
        IM::BaseDefine::MsgType nType;
        uint32_t nFromId;
        getLastMsg(nGroupId, nMsgId, strMsgData, nType, nFromId);
        if(IM::BaseDefine::MsgType_IsValid(nType))
        {
          cUnreadInfo.set_latest_msg_id(nMsgId);
          cUnreadInfo.set_latest_msg_data(strMsgData);
          cUnreadInfo.set_latest_msg_type(nType);
          cUnreadInfo.set_latest_msg_from_user_id(nFromId);
          lsUnreadCount.push_back(cUnreadInfo);
        }
        else
        {
          log("invalid msgType. userId=%u, groupId=%u, msgType=%u, msgId=%u", nUserId, nGroupId, nType, nMsgId);
        }
      }
    }
    pCacheManager->RelCacheConn(pCacheConn);
  }
  else
  {
    log("no cache connection for unread");
  }
}

/**
 *  获取一个群组的msgId，自增，通过redis控制
 *
 *  @param nGroupId 群Id
 *
 *  @return 返回msgId
 */
uint32_t CGroupMessageModel::getMsgId(uint32_t nGroupId)
{
  uint32_t nMsgId = 0;
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
  if(pCacheConn)
  {
    // TODO
    string strKey = "group_msg_id_" + int2string(nGroupId);
    nMsgId = pCacheConn->incrBy(strKey, 1);
    pCacheManager->RelCacheConn(pCacheConn);
  }
  else
  {
    log("no cache connection for unread");
  }
  return nMsgId;
}

/**
 *  获取一个群的最后一条消息
 *
 *  @param nGroupId   群Id
 *  @param nMsgId     最后一条消息的msgId,引用
 *  @param strMsgData 最后一条消息的内容,引用
 *  @param nMsgType   最后一条消息的类型,引用
 */
void CGroupMessageModel::getLastMsg(uint32_t nGroupId, uint32_t &nMsgId, string &strMsgData, IM::BaseDefine::MsgType &nMsgType, uint32_t& nFromId)
{
  string strTableName = "IMGroupMessage_" + int2string(nGroupId % 8);

  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  if (pDBConn)
  {
    string strSql = "select msgId, type,userId, content from " + strTableName + " where groupId = " + int2string(nGroupId) + " and status = 0 order by created desc, id desc limit 1";

    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if (pResultSet)
    {
      while(pResultSet->Next()) {
        nMsgId = pResultSet->GetInt("msgId");
        nMsgType = IM::BaseDefine::MsgType(pResultSet->GetInt("type"));
        nFromId = pResultSet->GetInt("userId");
        if(nMsgType == IM::BaseDefine::MSG_TYPE_GROUP_AUDIO)
        {
          // "[语音]"加密后的字符串
          strMsgData = strAudioEnc;
        }
        else
        {
          strMsgData = pResultSet->GetString("content");
        }
      }
      delete pResultSet;
    }
    else
    {
      log("no result set for sql: %s", strSql.c_str());
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_slave");
  }
}

/**
 *  获取某个用户所有群的所有未读计数之和
 *
 *  @param nUserId   用户Id
 *  @param nTotalCnt 未读计数之后,引用
 */
void CGroupMessageModel::getUnReadCntAll(uint32_t nUserId, uint32_t &nTotalCnt)
{
  list<uint32_t> lsGroupId;
  CGroupModel::getInstance()->getUserGroupIds(nUserId, lsGroupId, 0);
  uint32_t nCount = 0;

  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
  if (pCacheConn)
  {
    for(auto it=lsGroupId.begin(); it!=lsGroupId.end(); ++it)
    {
      uint32_t nGroupId = *it;
      string strGroupKey = int2string(nGroupId) + GROUP_TOTAL_MSG_COUNTER_REDIS_KEY_SUFFIX;
      string strGroupCnt = pCacheConn->hget(strGroupKey, GROUP_COUNTER_SUBKEY_COUNTER_FIELD);
      if(strGroupCnt.empty())
      {
        //                log("hget %s : count failed !", strGroupKey.c_str());
        continue;
      }
      uint32_t nGroupCnt = (uint32_t)(atoi(strGroupCnt.c_str()));

      string strUserKey = int2string(nUserId) + "_" + int2string(nGroupId) + GROUP_USER_MSG_COUNTER_REDIS_KEY_SUFFIX;
      string strUserCnt = pCacheConn->hget(strUserKey, GROUP_COUNTER_SUBKEY_COUNTER_FIELD);

      uint32_t nUserCnt = ( strUserCnt.empty() ? 0 : ((uint32_t)atoi(strUserCnt.c_str())) );
      if(nGroupCnt >= nUserCnt) {
        nCount = nGroupCnt - nUserCnt;
      }
      if(nCount > 0)
      {
        nTotalCnt += nCount;
      }
    }
    pCacheManager->RelCacheConn(pCacheConn);
  }
  else
  {
    log("no cache connection for unread");
  }
}

void CGroupMessageModel::getMsgByMsgId(uint32_t nUserId, uint32_t nGroupId, const list<uint32_t> &lsMsgId, list<IM::BaseDefine::MsgInfo> &lsMsg)
{
  if(!lsMsgId.empty())
  {
    if (CGroupModel::getInstance()->isInGroup(nUserId, nGroupId))
    {
      CDBManager* pDBManager = CDBManager::getInstance();
      CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
      if (pDBConn)
      {
        string strTableName = "IMGroupMessage_" + int2string(nGroupId % 8);
        uint32_t nUpdated = CGroupModel::getInstance()->getUserJoinTime(nGroupId, nUserId);
        string strClause ;
        bool bFirst = true;
        for(auto it= lsMsgId.begin(); it!=lsMsgId.end();++it)
        {
          if (bFirst) {
            bFirst = false;
            strClause = int2string(*it);
          }
          else
          {
            strClause += ("," + int2string(*it));
          }
        }

        string strSql = "select * from " + strTableName + " where groupId=" + int2string(nGroupId) + " and msgId in (" + strClause + ") and status=0 and created >= " + int2string(nUpdated) + " order by created desc, id desc limit 100";
        CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
        if (pResultSet)
        {
          while (pResultSet->Next())
          {
            IM::BaseDefine::MsgInfo msg;
            msg.set_msg_id(pResultSet->GetInt("msgId"));
            msg.set_from_session_id(pResultSet->GetInt("userId"));
            msg.set_create_time(pResultSet->GetInt("created"));
            IM::BaseDefine::MsgType nMsgType = IM::BaseDefine::MsgType(pResultSet->GetInt("type"));
            if(IM::BaseDefine::MsgType_IsValid(nMsgType))
            {
              msg.set_msg_type(nMsgType);
              msg.set_msg_data(pResultSet->GetString("content"));
              lsMsg.push_back(msg);
            }
            else
            {
              log("invalid msgType. userId=%u, groupId=%u, msgType=%u", nUserId, nGroupId, nMsgType);
            }
          }
          delete pResultSet;
        }
        else
        {
          log("no result set for sql:%s", strSql.c_str());
        }
        pDBManager->RelDBConn(pDBConn);
        if(!lsMsg.empty())
        {
          CAudioModel::getInstance()->readAudios(lsMsg);
        }
      }
      else
      {
        log("no db connection for teamtalk_slave");
      }
    }
    else
    {
      log("%u is not in group:%u", nUserId, nGroupId);
    }
  }
  else
  {
    log("msgId is empty.");
  }
}

bool CGroupMessageModel::resetMsgId(uint32_t nGroupId)
{
  bool bRet = false;
  CacheManager* pCacheManager = CacheManager::getInstance();
  CacheConn* pCacheConn = pCacheManager->GetCacheConn("unread");
  if(pCacheConn)
  {
    string strKey = "group_msg_id_" + int2string(nGroupId);
    string strValue = "0";
    string strReply = pCacheConn->set(strKey, strValue);
    if(strReply == strValue)
    {
      bRet = true;
    }
    pCacheManager->RelCacheConn(pCacheConn);
  }
  return bRet;
}

/* db_proxy_server - business - MessageCounter.h */
#ifndef MESSAGECOUNTER_H_
#define MESSAGECOUNTER_H_

#include "ImPduBase.h"
namespace DB_PROXY {

/* getUnreadMsgCounter 获取未读消息和消息数
 * clearUnreadMsgCounter 清除未读消息和消息数
 * setDevicesToken 设置设备推送标识
 * getDevicesToken 推送消息获取未读消息数
 */
void getUnreadMsgCounter(CImPdu* pPdu, uint32_t conn_uuid);
void clearUnreadMsgCounter(CImPdu* pPdu, uint32_t conn_uuid);
void setDevicesToken(CImPdu* pPdu, uint32_t conn_uuid);
void getDevicesToken(CImPdu* pPdu, uint32_t conn_uuid);

};

#endif /* MESSAGECOUNTER_H_ */

/* db_proxy_server - business - MessageCounter.cpp */
#include "../ProxyConn.h"
#include "../CachePool.h"
#include "MessageCounter.h"
#include "MessageModel.h"
#include "GroupMessageModel.h"
#include "IM.Message.pb.h"
#include "IM.BaseDefine.pb.h"
#include "IM.Login.pb.h"
#include "IM.Server.pb.h"
#include "UserModel.h"
#include<time.h>

namespace DB_PROXY {

/* 获取未读消息和消息数 */
void getUnreadMsgCounter(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Message::IMUnreadMsgCntReq msg;
  IM::Message::IMUnreadMsgCntRsp msgResp;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    CImPdu* pPduResp = new CImPdu;

    uint32_t nUserId = msg.user_id();

    list<IM::BaseDefine::UnreadInfo> lsUnreadCount;
    uint32_t nTotalCnt = 0;

    CMessageModel::getInstance()->getUnreadMsgCount(nUserId, nTotalCnt, lsUnreadCount);
    CGroupMessageModel::getInstance()->getUnreadMsgCount(nUserId, nTotalCnt, lsUnreadCount);
    msgResp.set_user_id(nUserId);
    msgResp.set_total_cnt(nTotalCnt);
    for(auto it= lsUnreadCount.begin(); it!=lsUnreadCount.end(); ++it)
    {
      IM::BaseDefine::UnreadInfo* pInfo = msgResp.add_unreadinfo_list();
      //*pInfo = *it;
      pInfo->set_session_id(it->session_id());
      pInfo->set_session_type(it->session_type());
      pInfo->set_unread_cnt(it->unread_cnt());
      pInfo->set_latest_msg_id(it->latest_msg_id());
      pInfo->set_latest_msg_data(it->latest_msg_data());
      pInfo->set_latest_msg_type(it->latest_msg_type());
      pInfo->set_latest_msg_from_user_id(it->latest_msg_from_user_id());
    }


    log("userId=%d, unreadCnt=%u, totalCount=%u", nUserId, msgResp.unreadinfo_list_size(), nTotalCnt);
    msgResp.set_attach_data(msg.attach_data());
    pPduResp->SetPBMsg(&msgResp);
    pPduResp->SetSeqNum(pPdu->GetSeqNum());
    pPduResp->SetServiceId(IM::BaseDefine::SID_MSG);
    pPduResp->SetCommandId(IM::BaseDefine::CID_MSG_UNREAD_CNT_RESPONSE);
    CProxyConn::AddResponsePdu(conn_uuid, pPduResp);
  }
  else
  {
    log("parse pb failed");
  }
}

/* 清除未读消息和消息数 */
void clearUnreadMsgCounter(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Message::IMMsgDataReadAck msg;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    uint32_t nUserId = msg.user_id();
    uint32_t nFromId = msg.session_id();
    IM::BaseDefine::SessionType nSessionType = msg.session_type();
    CUserModel::getInstance()->clearUserCounter(nUserId, nFromId, nSessionType);
    log("userId=%u, peerId=%u, type=%u", nFromId, nUserId, nSessionType);
  }
  else
  {
    log("parse pb failed");
  }
}

/* 设置设备推送标识 */
void setDevicesToken(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Login::IMDeviceTokenReq msg;
  IM::Login::IMDeviceTokenRsp msgResp;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    uint32_t nUserId = msg.user_id();
    string strToken = msg.device_token();
    CImPdu* pPduResp = new CImPdu;
    CacheManager* pCacheManager = CacheManager::getInstance();
    CacheConn* pCacheConn = pCacheManager->GetCacheConn("token");
    if (pCacheConn)
    {
      IM::BaseDefine::ClientType nClientType = msg.client_type();
      string strValue;
      if(IM::BaseDefine::CLIENT_TYPE_IOS == nClientType)
      {
        strValue = "ios:"+strToken;
      }
      else if(IM::BaseDefine::CLIENT_TYPE_ANDROID == nClientType)
      {
        strValue = "android:"+strToken;
      }
      else
      {
        strValue = strToken;
      }

      string strOldValue = pCacheConn->get("device_"+int2string(nUserId));

      if(!strOldValue.empty())
      {
        size_t nPos = strOldValue.find(":");
        if(nPos!=string::npos)
        {
          string strOldToken = strOldValue.substr(nPos + 1);
          string strReply = pCacheConn->get("device_"+strOldToken);
          if (!strReply.empty()) {
            string strNewValue("");
            pCacheConn->set("device_"+strOldToken, strNewValue);
          }
        }
      }

      pCacheConn->set("device_"+int2string(nUserId), strValue);
      string strNewValue = int2string(nUserId);
      pCacheConn->set("device_"+strToken, strNewValue);

      log("setDeviceToken. userId=%u, deviceToken=%s", nUserId, strToken.c_str());
      pCacheManager->RelCacheConn(pCacheConn);
    }
    else
    {
      log("no cache connection for token");
    }

    log("setDeviceToken. userId=%u, deviceToken=%s", nUserId, strToken.c_str());
    msgResp.set_attach_data(msg.attach_data());
    msgResp.set_user_id(nUserId);
    pPduResp->SetPBMsg(&msgResp);
    pPduResp->SetSeqNum(pPdu->GetSeqNum());
    pPduResp->SetServiceId(IM::BaseDefine::SID_LOGIN);
    pPduResp->SetCommandId(IM::BaseDefine::CID_LOGIN_RES_DEVICETOKEN);
    CProxyConn::AddResponsePdu(conn_uuid, pPduResp);
  }
  else
  {
    log("parse pb failed");
  }
}

/* 推送消息获取未读消息数 */
void getDevicesToken(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Server::IMGetDeviceTokenReq msg;
  IM::Server::IMGetDeviceTokenRsp msgResp;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    CacheManager* pCacheManager = CacheManager::getInstance();
    CacheConn* pCacheConn = pCacheManager->GetCacheConn("token");
    CImPdu* pPduResp = new CImPdu;
    uint32_t nCnt = msg.user_id_size();

    // 对于ios，不推送
    // 对于android，由客户端处理
    bool is_check_shield_status = false;
    time_t now = time(NULL);
    struct tm* _tm = localtime(&now);
    if (_tm->tm_hour >= 22 || _tm->tm_hour <=7 ) {
      is_check_shield_status = true;
    }
    if (pCacheConn)
    {
      vector<string> vecTokens;
      for (uint32_t i=0; i<nCnt; ++i) {
        string strKey = "device_"+int2string(msg.user_id(i));
        vecTokens.push_back(strKey);
      }
      map<string, string> mapTokens;
      bool bRet = pCacheConn->mget(vecTokens, mapTokens);
      pCacheManager->RelCacheConn(pCacheConn);

      if(bRet)
      {
        for (auto it=mapTokens.begin(); it!=mapTokens.end(); ++it) {
          string strKey = it->first;
          size_t nPos = strKey.find("device_");
          if( nPos != string::npos)
          {
            string strUserId = strKey.substr(nPos + strlen("device_"));
            uint32_t nUserId = string2int(strUserId);
            string strValue = it->second;
            nPos = strValue.find(":");
            if(nPos!=string::npos)
            {
              string strType = strValue.substr(0, nPos);
              string strToken = strValue.substr(nPos + 1);
              IM::BaseDefine::ClientType nClientType = IM::BaseDefine::ClientType(0);
              if(strType == "ios")
              {
                // 过滤出已经设置勿打扰并且为晚上22：00～07：00
                uint32_t shield_status = 0;
                if (is_check_shield_status) {
                  CUserModel::getInstance()->getPushShield(nUserId, &shield_status);
                }

                if (shield_status == 1) {
                  // 对IOS处理
                  continue;
                } else {
                  nClientType = IM::BaseDefine::CLIENT_TYPE_IOS;
                }

                // nClientType = IM::BaseDefine::CLIENT_TYPE_IOS;
                // end
              }
              else if(strType == "android")
              {
                nClientType = IM::BaseDefine::CLIENT_TYPE_ANDROID;
              }
              if(IM::BaseDefine::ClientType_IsValid(nClientType))
              {
                IM::BaseDefine::UserTokenInfo* pToken = msgResp.add_user_token_info();
                pToken->set_user_id(nUserId);
                pToken->set_token(strToken);
                pToken->set_user_type(nClientType);
                uint32_t nTotalCnt = 0;
                CMessageModel::getInstance()->getUnReadCntAll(nUserId, nTotalCnt);
                CGroupMessageModel::getInstance()->getUnReadCntAll(nUserId, nTotalCnt);
                pToken->set_push_count(nTotalCnt);
                pToken->set_push_type(1);
              }
              else
              {
                log("invalid clientType.clientType=%u", nClientType);
              }
            }
            else
            {
              log("invalid value. value=%s", strValue.c_str());
            }

          }
          else
          {
            log("invalid key.key=%s", strKey.c_str());
          }
        }
      }
      else
      {
        log("mget failed!");
      }
    }
    else
    {
      log("no cache connection for token");
    }

    log("req devices token.reqCnt=%u, resCnt=%u", nCnt, msgResp.user_token_info_size());

    msgResp.set_attach_data(msg.attach_data());
    pPduResp->SetPBMsg(&msgResp);
    pPduResp->SetSeqNum(pPdu->GetSeqNum());
    pPduResp->SetServiceId(IM::BaseDefine::SID_OTHER);
    pPduResp->SetCommandId(IM::BaseDefine::CID_OTHER_GET_DEVICE_TOKEN_RSP);
    CProxyConn::AddResponsePdu(conn_uuid, pPduResp);
  }
  else
  {
    log("parse pb failed");
  }
}

};

/* db_proxy_server - business - MessageContent.h */
#ifndef MESSAGECOUTENT_H_
#define MESSAGECOUTENT_H_

#include "ImPduBase.h"

/* getMessage 获取消息记录
 * sendMessage 发送消息
 * getMessageById 根据id获取消息
 * getLatestMsgId 获取最后一条消息记录
 */
namespace DB_PROXY {

void getMessage(CImPdu* pPdu, uint32_t conn_uuid);
void sendMessage(CImPdu* pPdu, uint32_t conn_uuid);
void getMessageById(CImPdu* pPdu, uint32_t conn_uuid);
void getLatestMsgId(CImPdu* pPdu, uint32_t conn_uuid);

};

#endif /* MESSAGECOUTENT_H_ */

/* db_proxy_server - business - MessageContent.cpp */
#include "../ProxyConn.h"
#include "../CachePool.h"
#include "../DBPool.h"
#include "MessageContent.h"
#include "MessageModel.h"
#include "GroupMessageModel.h"
#include "Common.h"
#include "GroupModel.h"
#include "ImPduBase.h"
#include "IM.Message.pb.h"
#include "SessionModel.h"
#include "RelationModel.h"

namespace DB_PROXY {

/* 获取消息记录(包括个人消息和群组消息) */
void getMessage(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Message::IMGetMsgListReq msg;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    uint32_t nUserId = msg.user_id();
    uint32_t nPeerId = msg.session_id();
    uint32_t nMsgId = msg.msg_id_begin();
    uint32_t nMsgCnt = msg.msg_cnt();
    IM::BaseDefine::SessionType nSessionType = msg.session_type();
    if(IM::BaseDefine::SessionType_IsValid(nSessionType))
    {
      CImPdu* pPduResp = new CImPdu;
      IM::Message::IMGetMsgListRsp msgResp;

      list<IM::BaseDefine::MsgInfo> lsMsg;

      if(nSessionType == IM::BaseDefine::SESSION_TYPE_SINGLE)//获取个人消息
      {
        CMessageModel::getInstance()->getMessage(nUserId, nPeerId, nMsgId, nMsgCnt, lsMsg);
      }
      else if(nSessionType == IM::BaseDefine::SESSION_TYPE_GROUP)//获取群消息
      {
        if(CGroupModel::getInstance()->isInGroup(nUserId, nPeerId))
        {
          CGroupMessageModel::getInstance()->getMessage(nUserId, nPeerId, nMsgId, nMsgCnt, lsMsg);
        }
      }

      msgResp.set_user_id(nUserId);
      msgResp.set_session_id(nPeerId);
      msgResp.set_msg_id_begin(nMsgId);
      msgResp.set_session_type(nSessionType);
      for(auto it=lsMsg.begin(); it!=lsMsg.end();++it)
      {
        IM::BaseDefine::MsgInfo* pMsg = msgResp.add_msg_list();
        //*pMsg = *it;
        pMsg->set_msg_id(it->msg_id());
        pMsg->set_from_session_id(it->from_session_id());
        pMsg->set_create_time(it->create_time());
        pMsg->set_msg_type(it->msg_type());
        pMsg->set_msg_data(it->msg_data());
        //log("userId=%u, peerId=%u, msgId=%u", nUserId, nPeerId, it->msg_id());
      }

      log("userId=%u, peerId=%u, msgId=%u, msgCnt=%u, count=%u", nUserId, nPeerId, nMsgId, nMsgCnt, msgResp.msg_list_size());
      msgResp.set_attach_data(msg.attach_data());
      pPduResp->SetPBMsg(&msgResp);
      pPduResp->SetSeqNum(pPdu->GetSeqNum());
      pPduResp->SetServiceId(IM::BaseDefine::SID_MSG);
      pPduResp->SetCommandId(IM::BaseDefine::CID_MSG_LIST_RESPONSE);
      CProxyConn::AddResponsePdu(conn_uuid, pPduResp);
    }
    else
    {
      log("invalid sessionType. userId=%u, peerId=%u, msgId=%u, msgCnt=%u, sessionType=%u",
          nUserId, nPeerId, nMsgId, nMsgCnt, nSessionType);
    }
  }
  else
  {
    log("parse pb failed");
  }
}

/* 发送消息(消息类型: 群组文本消息,群组语音消息,个人文本消息,个人语音消息) */
void sendMessage(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Message::IMMsgData msg;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    uint32_t nFromId = msg.from_user_id();
    uint32_t nToId = msg.to_session_id();
    uint32_t nCreateTime = msg.create_time();
    IM::BaseDefine::MsgType nMsgType = msg.msg_type();
    uint32_t nMsgLen = msg.msg_data().length();

    uint32_t nNow = (uint32_t)time(NULL);
    if (IM::BaseDefine::MsgType_IsValid(nMsgType))
    {
      if(nMsgLen != 0)
      {
        CImPdu* pPduResp = new CImPdu;

        uint32_t nMsgId = INVALID_VALUE;
        uint32_t nSessionId = INVALID_VALUE;
        uint32_t nPeerSessionId = INVALID_VALUE;

        CMessageModel* pMsgModel = CMessageModel::getInstance();
        CGroupMessageModel* pGroupMsgModel = CGroupMessageModel::getInstance();
        if(nMsgType == IM::BaseDefine::MSG_TYPE_GROUP_TEXT) {
          CGroupModel* pGroupModel = CGroupModel::getInstance();
          if (pGroupModel->isValidateGroupId(nToId) && pGroupModel->isInGroup(nFromId, nToId))
          {
            nSessionId = CSessionModel::getInstance()->getSessionId(nFromId, nToId, IM::BaseDefine::SESSION_TYPE_GROUP, false);
            if (INVALID_VALUE == nSessionId) {
              nSessionId = CSessionModel::getInstance()->addSession(nFromId, nToId, IM::BaseDefine::SESSION_TYPE_GROUP);
            }
            if(nSessionId != INVALID_VALUE)
            {
              nMsgId = pGroupMsgModel->getMsgId(nToId);
              if (nMsgId != INVALID_VALUE) {
                pGroupMsgModel->sendMessage(nFromId, nToId, nMsgType, nCreateTime, nMsgId, (string&)msg.msg_data());
                CSessionModel::getInstance()->updateSession(nSessionId, nNow);
              }
            }
          }
          else
          {
            log("invalid groupId. fromId=%u, groupId=%u", nFromId, nToId);
            delete pPduResp;
            return;
          }
        } else if (nMsgType == IM::BaseDefine::MSG_TYPE_GROUP_AUDIO) {
          CGroupModel* pGroupModel = CGroupModel::getInstance();
          if (pGroupModel->isValidateGroupId(nToId)&& pGroupModel->isInGroup(nFromId, nToId))
          {
            nSessionId = CSessionModel::getInstance()->getSessionId(nFromId, nToId, IM::BaseDefine::SESSION_TYPE_GROUP, false);
            if (INVALID_VALUE == nSessionId) {
              nSessionId = CSessionModel::getInstance()->addSession(nFromId, nToId, IM::BaseDefine::SESSION_TYPE_GROUP);
            }
            if(nSessionId != INVALID_VALUE)
            {
              nMsgId = pGroupMsgModel->getMsgId(nToId);
              if(nMsgId != INVALID_VALUE)
              {
                pGroupMsgModel->sendAudioMessage(nFromId, nToId, nMsgType, nCreateTime, nMsgId, msg.msg_data().c_str(), nMsgLen);
                CSessionModel::getInstance()->updateSession(nSessionId, nNow);
              }
            }
          }
          else
          {
            log("invalid groupId. fromId=%u, groupId=%u", nFromId, nToId);
            delete pPduResp;
            return;
          }
        } else if(nMsgType== IM::BaseDefine::MSG_TYPE_SINGLE_TEXT) {
          if (nFromId != nToId) {
            nSessionId = CSessionModel::getInstance()->getSessionId(nFromId, nToId, IM::BaseDefine::SESSION_TYPE_SINGLE, false);
            if (INVALID_VALUE == nSessionId) {
              nSessionId = CSessionModel::getInstance()->addSession(nFromId, nToId, IM::BaseDefine::SESSION_TYPE_SINGLE);
            }
            nPeerSessionId = CSessionModel::getInstance()->getSessionId(nToId, nFromId, IM::BaseDefine::SESSION_TYPE_SINGLE, false);
            if(INVALID_VALUE ==  nPeerSessionId)
            {
              nSessionId = CSessionModel::getInstance()->addSession(nToId, nFromId, IM::BaseDefine::SESSION_TYPE_SINGLE);
            }
            uint32_t nRelateId = CRelationModel::getInstance()->getRelationId(nFromId, nToId, true);
            if(nSessionId != INVALID_VALUE && nRelateId != INVALID_VALUE)
            {
              nMsgId = pMsgModel->getMsgId(nRelateId);
              if(nMsgId != INVALID_VALUE)
              {
                pMsgModel->sendMessage(nRelateId, nFromId, nToId, nMsgType, nCreateTime, nMsgId, (string&)msg.msg_data());
                CSessionModel::getInstance()->updateSession(nSessionId, nNow);
                CSessionModel::getInstance()->updateSession(nPeerSessionId, nNow);
              }
              else
              {
                log("msgId is invalid. fromId=%u, toId=%u, nRelateId=%u, nSessionId=%u, nMsgType=%u", nFromId, nToId, nRelateId, nSessionId, nMsgType);
              }
            }
            else{
              log("sessionId or relateId is invalid. fromId=%u, toId=%u, nRelateId=%u, nSessionId=%u, nMsgType=%u", nFromId, nToId, nRelateId, nSessionId, nMsgType);
            }
          }
          else
          {
            log("send msg to self. fromId=%u, toId=%u, msgType=%u", nFromId, nToId, nMsgType);
          }

        } else if(nMsgType == IM::BaseDefine::MSG_TYPE_SINGLE_AUDIO) {

          if(nFromId != nToId)
          {
            nSessionId = CSessionModel::getInstance()->getSessionId(nFromId, nToId, IM::BaseDefine::SESSION_TYPE_SINGLE, false);
            if (INVALID_VALUE == nSessionId) {
              nSessionId = CSessionModel::getInstance()->addSession(nFromId, nToId, IM::BaseDefine::SESSION_TYPE_SINGLE);
            }
            nPeerSessionId = CSessionModel::getInstance()->getSessionId(nToId, nFromId, IM::BaseDefine::SESSION_TYPE_SINGLE, false);
            if(INVALID_VALUE ==  nPeerSessionId)
            {
              nSessionId = CSessionModel::getInstance()->addSession(nToId, nFromId, IM::BaseDefine::SESSION_TYPE_SINGLE);
            }
            uint32_t nRelateId = CRelationModel::getInstance()->getRelationId(nFromId, nToId, true);
            if(nSessionId != INVALID_VALUE && nRelateId != INVALID_VALUE)
            {
              nMsgId = pMsgModel->getMsgId(nRelateId);
              if(nMsgId != INVALID_VALUE) {
                pMsgModel->sendAudioMessage(nRelateId, nFromId, nToId, nMsgType, nCreateTime, nMsgId, msg.msg_data().c_str(), nMsgLen);
                CSessionModel::getInstance()->updateSession(nSessionId, nNow);
                CSessionModel::getInstance()->updateSession(nPeerSessionId, nNow);
              }
              else {
                log("msgId is invalid. fromId=%u, toId=%u, nRelateId=%u, nSessionId=%u, nMsgType=%u", nFromId, nToId, nRelateId, nSessionId, nMsgType);
              }
            }
            else {
              log("sessionId or relateId is invalid. fromId=%u, toId=%u, nRelateId=%u, nSessionId=%u, nMsgType=%u", nFromId, nToId, nRelateId, nSessionId, nMsgType);
            }
          }
          else
          {
            log("send msg to self. fromId=%u, toId=%u, msgType=%u", nFromId, nToId, nMsgType);
          }
        }

        log("fromId=%u, toId=%u, type=%u, msgId=%u, sessionId=%u", nFromId, nToId, nMsgType, nMsgId, nSessionId);

        msg.set_msg_id(nMsgId);
        pPduResp->SetPBMsg(&msg);
        pPduResp->SetSeqNum(pPdu->GetSeqNum());
        pPduResp->SetServiceId(IM::BaseDefine::SID_MSG);
        pPduResp->SetCommandId(IM::BaseDefine::CID_MSG_DATA);
        CProxyConn::AddResponsePdu(conn_uuid, pPduResp);
      }
      else
      {
        log("msgLen error. fromId=%u, toId=%u, msgType=%u", nFromId, nToId, nMsgType);
      }
    }
    else
    {
      log("invalid msgType.fromId=%u, toId=%u, msgType=%u", nFromId, nToId, nMsgType);
    }
  }
  else
  {
    log("parse pb failed");
  }
}

/* 根据id获取消息 */
void getMessageById(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Message::IMGetMsgByIdReq msg;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    uint32_t nUserId = msg.user_id();
    IM::BaseDefine::SessionType nType = msg.session_type();
    uint32_t nPeerId = msg.session_id();
    list<uint32_t> lsMsgId;
    uint32_t nCnt = msg.msg_id_list_size();
    for(uint32_t i=0; i<nCnt; ++i)
    {
      lsMsgId.push_back(msg.msg_id_list(i));
    }
    if (IM::BaseDefine::SessionType_IsValid(nType))
    {
      CImPdu* pPduResp = new CImPdu;
      IM::Message::IMGetMsgByIdRsp msgResp;

      list<IM::BaseDefine::MsgInfo> lsMsg;
      if(IM::BaseDefine::SESSION_TYPE_SINGLE == nType)
      {
        CMessageModel::getInstance()->getMsgByMsgId(nUserId, nPeerId, lsMsgId, lsMsg);
      }
      else if(IM::BaseDefine::SESSION_TYPE_GROUP)
      {
        CGroupMessageModel::getInstance()->getMsgByMsgId(nUserId, nPeerId, lsMsgId, lsMsg);
      }
      msgResp.set_user_id(nUserId);
      msgResp.set_session_id(nPeerId);
      msgResp.set_session_type(nType);
      for(auto it=lsMsg.begin(); it!=lsMsg.end(); ++it)
      {
        IM::BaseDefine::MsgInfo* pMsg = msgResp.add_msg_list();
        pMsg->set_msg_id(it->msg_id());
        pMsg->set_from_session_id(it->from_session_id());
        pMsg->set_create_time(it->create_time());
        pMsg->set_msg_type(it->msg_type());
        pMsg->set_msg_data(it->msg_data());
      }
      log("userId=%u, peerId=%u, sessionType=%u, reqMsgCnt=%u, resMsgCnt=%u", nUserId, nPeerId, nType, msg.msg_id_list_size(), msgResp.msg_list_size());
      msgResp.set_attach_data(msg.attach_data());
      pPduResp->SetPBMsg(&msgResp);
      pPduResp->SetSeqNum(pPdu->GetSeqNum());
      pPduResp->SetServiceId(IM::BaseDefine::SID_MSG);
      pPduResp->SetCommandId(IM::BaseDefine::CID_MSG_GET_BY_MSG_ID_RES);
      CProxyConn::AddResponsePdu(conn_uuid, pPduResp);
    }
    else
    {
      log("invalid sessionType. fromId=%u, toId=%u, sessionType=%u, msgCnt=%u", nUserId, nPeerId, nType, nCnt);
    }
  }
  else
  {
    log("parse pb failed");
  }
}

/* 获取最后一条消息记录 */
void getLatestMsgId(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Message::IMGetLatestMsgIdReq msg;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    uint32_t nUserId = msg.user_id();
    IM::BaseDefine::SessionType nType = msg.session_type();
    uint32_t nPeerId = msg.session_id();
    if (IM::BaseDefine::SessionType_IsValid(nType)) {
      CImPdu* pPduResp = new CImPdu;
      IM::Message::IMGetLatestMsgIdRsp msgResp;
      msgResp.set_user_id(nUserId);
      msgResp.set_session_type(nType);
      msgResp.set_session_id(nPeerId);
      uint32_t nMsgId = INVALID_VALUE;
      if(IM::BaseDefine::SESSION_TYPE_SINGLE == nType)
      {
        string strMsg;
        IM::BaseDefine::MsgType nMsgType;
        CMessageModel::getInstance()->getLastMsg(nUserId, nPeerId, nMsgId, strMsg, nMsgType, 1);
      }
      else
      {
        string strMsg;
        IM::BaseDefine::MsgType nMsgType;
        uint32_t nFromId = INVALID_VALUE;
        CGroupMessageModel::getInstance()->getLastMsg(nPeerId, nMsgId, strMsg, nMsgType, nFromId);
      }
      msgResp.set_latest_msg_id(nMsgId);
      log("userId=%u, peerId=%u, sessionType=%u, msgId=%u", nUserId, nPeerId, nType,nMsgId);
      msgResp.set_attach_data(msg.attach_data());
      pPduResp->SetPBMsg(&msgResp);
      pPduResp->SetSeqNum(pPdu->GetSeqNum());
      pPduResp->SetServiceId(IM::BaseDefine::SID_MSG);
      pPduResp->SetCommandId(IM::BaseDefine::CID_MSG_GET_LATEST_MSG_ID_RSP);
      CProxyConn::AddResponsePdu(conn_uuid, pPduResp);

    }
    else
    {
      log("invalid sessionType. userId=%u, peerId=%u, sessionType=%u", nUserId, nPeerId, nType);
    }
  }
  else
  {
    log("parse pb failed");
  }
}

};

/* db_proxy_server - business - DepartModel.h */
#ifndef __DEPARTMODEL_H__
#define __DEPARTMODEL_H__

#include "ImPduBase.h"
#include "IM.BaseDefine.pb.h"

/* getChgedDeptId 获取更新过的部门id
 * getDepts 获取部门信息(多个)
 * getDept  获取部门信息
 */
class CDepartModel {
public:
  static CDepartModel* getInstance();
  ~CDepartModel() {}
  void getChgedDeptId(uint32_t& nLastTime, list<uint32_t>& lsChangedIds);
  void getDepts(list<uint32_t>& lsDeptIds, list<IM::BaseDefine::DepartInfo>& lsDepts);
  void getDept(uint32_t nDeptId, IM::BaseDefine::DepartInfo& cDept);
private:
  CDepartModel(){};
private:
  static CDepartModel* m_pInstance;
};

#endif /*defined(__DEPARTMODEL_H__) */

/* db_proxy_server - business - DepartModel.cpp */
#include "DepartModel.h"
#include "../DBPool.h"

CDepartModel* CDepartModel::m_pInstance = NULL;

CDepartModel* CDepartModel::getInstance()
{
  if(NULL == m_pInstance)
  {
    m_pInstance = new CDepartModel();
  }
  return m_pInstance;
}

/* 获取更新过的部门id */
void CDepartModel::getChgedDeptId(uint32_t& nLastTime, list<uint32_t>& lsChangedIds)
{
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  if (pDBConn)
  {
    string strSql = "select id, updated from IMDepart where updated > " + int2string(nLastTime);
    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if(pResultSet)
    {
      while (pResultSet->Next()) {
        uint32_t id = pResultSet->GetInt("id");
        uint32_t nUpdated = pResultSet->GetInt("updated");
        if(nLastTime < nUpdated)
        {
          nLastTime = nUpdated;
        }
        lsChangedIds.push_back(id);
      }
      delete  pResultSet;
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_slave.");
  }
}

/* 获取部门信息(多个) */
void CDepartModel::getDepts(list<uint32_t>& lsDeptIds, list<IM::BaseDefine::DepartInfo>& lsDepts)
{
  if(lsDeptIds.empty())
  {
    log("list is empty");
    return;
  }
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  if (pDBConn)
  {
    string strClause;
    bool bFirst = true;
    for (auto it=lsDeptIds.begin(); it!=lsDeptIds.end(); ++it) {
      if(bFirst)
      {
        bFirst = false;
        strClause += int2string(*it);
      }
      else
      {
        strClause += ("," + int2string(*it));
      }
    }
    string strSql = "select * from IMDepart where id in ( " + strClause + " )";
    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if(pResultSet)
    {
      while (pResultSet->Next()) {
        IM::BaseDefine::DepartInfo cDept;
        uint32_t nId = pResultSet->GetInt("id");
        uint32_t nParentId = pResultSet->GetInt("parentId");
        string strDeptName = pResultSet->GetString("departName");
        uint32_t nStatus = pResultSet->GetInt("status");
        uint32_t nPriority = pResultSet->GetInt("priority");
        if(IM::BaseDefine::DepartmentStatusType_IsValid(nStatus))
        {
          cDept.set_dept_id(nId);
          cDept.set_parent_dept_id(nParentId);
          cDept.set_dept_name(strDeptName);
          cDept.set_dept_status(IM::BaseDefine::DepartmentStatusType(nStatus));
          cDept.set_priority(nPriority);
          lsDepts.push_back(cDept);
        }
      }
      delete  pResultSet;
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_slave");
  }
}

/* 获取部门信息 */
void CDepartModel::getDept(uint32_t nDeptId, IM::BaseDefine::DepartInfo& cDept)
{
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  if (pDBConn)
  {
    string strSql = "select * from IMDepart where id = " + int2string(nDeptId);
    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if(pResultSet)
    {
      while (pResultSet->Next()) {
        uint32_t nId = pResultSet->GetInt("id");
        uint32_t nParentId = pResultSet->GetInt("parentId");
        string strDeptName = pResultSet->GetString("departName");
        uint32_t nStatus = pResultSet->GetInt("status");
        uint32_t nPriority = pResultSet->GetInt("priority");
        if(IM::BaseDefine::DepartmentStatusType_IsValid(nStatus))
        {
          cDept.set_dept_id(nId);
          cDept.set_parent_dept_id(nParentId);
          cDept.set_dept_name(strDeptName);
          cDept.set_dept_status(IM::BaseDefine::DepartmentStatusType(nStatus));
          cDept.set_priority(nPriority);
        }
      }
      delete  pResultSet;
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_slave");
  }
}

/* db_proxy_server - business - DepartAction.h */
#ifndef __DEPARTACTION_H__
#define __DEPARTACTION_H__
#include "ImPduBase.h"

/* getChgedDepart 获取更新过的部门信息 */
namespace DB_PROXY {
    
void getChgedDepart(CImPdu* pPdu, uint32_t conn_uuid);

};

#endif /*defined(__DEPARTACTION_H__) */

/* db_proxy_server - business - DepartAction.cpp */
#include "DepartAction.h"
#include "DepartModel.h"
#include "IM.Buddy.pb.h"
#include "../ProxyConn.h"

namespace DB_PROXY{

/* 获取更新过的部门信息 */
void getChgedDepart(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::Buddy::IMDepartmentReq msg;
  IM::Buddy::IMDepartmentRsp msgResp;
  if (msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength())) {

    CImPdu* pPduRes = new CImPdu;

    uint32_t nUserId = msg.user_id();
    uint32_t nLastUpdate = msg.latest_update_time();
    list<uint32_t> lsChangedIds;
    CDepartModel::getInstance()->getChgedDeptId(nLastUpdate, lsChangedIds);
    list<IM::BaseDefine::DepartInfo> lsDeparts;
    CDepartModel::getInstance()->getDepts(lsChangedIds, lsDeparts);

    msgResp.set_user_id(nUserId);
    msgResp.set_latest_update_time(nLastUpdate);
    for(auto it=lsDeparts.begin(); it!=lsDeparts.end(); ++it)
    {
      IM::BaseDefine::DepartInfo* pDeptInfo = msgResp.add_dept_list();
      pDeptInfo->set_dept_id(it->dept_id());
      pDeptInfo->set_priority(it->priority());
      pDeptInfo->set_dept_name(it->dept_name());
      pDeptInfo->set_parent_dept_id(it->parent_dept_id());
      pDeptInfo->set_dept_status(it->dept_status());
    }
    log("userId=%u, last_update=%u, cnt=%u", nUserId, nLastUpdate, lsDeparts.size());
    msgResp.set_attach_data(msg.attach_data());
    pPduRes->SetPBMsg(&msgResp);
    pPduRes->SetSeqNum(pPdu->GetSeqNum());
    pPduRes->SetServiceId(IM::BaseDefine::SID_BUDDY_LIST);
    pPduRes->SetCommandId(IM::BaseDefine::CID_BUDDY_LIST_DEPARTMENT_RESPONSE);
    CProxyConn::AddResponsePdu(conn_uuid, pPduRes);

  }
  else
  {
    log("parse pb failed");
  }
}

}

/* db_proxy_server - business - FileModel.h */
#ifndef __FILEMODEL_H__
#define __FILEMODEL_H__
#include "IM.File.pb.h"
#include "ImPduBase.h"

/* getOfflineFile 获取离线文件
 * addOfflineFile 添加离线文件
 * delOfflineFile 删除离线文件
 */
class CFileModel
{
public:
  virtual ~CFileModel();
  static CFileModel* getInstance();

  void getOfflineFile(uint32_t userId, list<IM::BaseDefine::OfflineFileInfo>& lsOffline);
  void addOfflineFile(uint32_t fromId, uint32_t toId, string& taskId, string& fileName, uint32_t fileSize);
  void delOfflineFile(uint32_t fromId, uint32_t toId, string& taskId);

private:
  CFileModel();

private:
  static CFileModel* m_pInstance;
};

#endif /*defined(__FILEMODEL_H__) */

/* db_proxy_server - business - FileModel.cpp */
#include "FileModel.h"
#include "../DBPool.h"

CFileModel* CFileModel::m_pInstance = NULL;

CFileModel::CFileModel()
{

}

CFileModel::~CFileModel()
{

}

CFileModel* CFileModel::getInstance()
{
  if (m_pInstance == NULL) {
    m_pInstance = new CFileModel();
  }
  return m_pInstance;
}

/* 获取离线文件 */
void CFileModel::getOfflineFile(uint32_t userId, list<IM::BaseDefine::OfflineFileInfo>& lsOffline)
{
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_slave");
  if (pDBConn)
  {
    string strSql = "select * from IMTransmitFile where toId="+int2string(userId) + " and status=0 order by created";
    CResultSet* pResultSet = pDBConn->ExecuteQuery(strSql.c_str());
    if(pResultSet)
    {
      while (pResultSet->Next())
      {
        IM::BaseDefine::OfflineFileInfo offlineFile;
        offlineFile.set_from_user_id(pResultSet->GetInt("fromId"));
        offlineFile.set_task_id(pResultSet->GetString("taskId"));
        offlineFile.set_file_name(pResultSet->GetString("fileName"));
        offlineFile.set_file_size(pResultSet->GetInt("size"));
        lsOffline.push_back(offlineFile);
      }
      delete pResultSet;
    }
    else
    {
      log("no result for:%s", strSql.c_str());
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_slave");
  }
}

/* 添加离线文件 */
void CFileModel::addOfflineFile(uint32_t fromId, uint32_t toId, string& taskId, string& fileName, uint32_t fileSize)
{
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if (pDBConn)
  {
    string strSql = "insert into IMTransmitFile (`fromId`,`toId`,`fileName`,`size`,`taskId`,`status`,`created`,`updated`) values(?,?,?,?,?,?,?,?)";

    // 必须在释放连接前delete CPrepareStatement对象，否则有可能多个线程操作mysql对象，会crash
    CPrepareStatement* pStmt = new CPrepareStatement();
    if (pStmt->Init(pDBConn->GetMysql(), strSql))
    {
      uint32_t status = 0;
      uint32_t nCreated = (uint32_t)time(NULL);

      uint32_t index = 0;
      pStmt->SetParam(index++, fromId);
      pStmt->SetParam(index++, toId);
      pStmt->SetParam(index++, fileName);
      pStmt->SetParam(index++, fileSize);
      pStmt->SetParam(index++, taskId);
      pStmt->SetParam(index++, status);
      pStmt->SetParam(index++, nCreated);
      pStmt->SetParam(index++, nCreated);

      bool bRet = pStmt->ExecuteUpdate();

      if (!bRet)
      {
        log("insert message failed: %s", strSql.c_str());
      }
    }
    delete pStmt;
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
}

/* 删除离线文件 */
void CFileModel::delOfflineFile(uint32_t fromId, uint32_t toId, string& taskId)
{
  CDBManager* pDBManager = CDBManager::getInstance();
  CDBConn* pDBConn = pDBManager->GetDBConn("teamtalk_master");
  if (pDBConn)
  {
    string strSql = "delete from IMTransmitFile where  fromId=" + int2string(fromId) + " and toId="+int2string(toId) + " and taskId='" + taskId + "'";
    if(pDBConn->ExecuteUpdate(strSql.c_str()))
    {
      log("delete offline file success.%d->%d:%s", fromId, toId, taskId.c_str());
    }
    else
    {
      log("delete offline file failed.%d->%d:%s", fromId, toId, taskId.c_str());
    }
    pDBManager->RelDBConn(pDBConn);
  }
  else
  {
    log("no db connection for teamtalk_master");
  }
}

/* db_proxy_server - business - FileAction.h */
#ifndef __FILEACTION_H__
#define __FILEACTION_H__

#include "ImPduBase.h"

/* hasOfflineFile 获取离线文件
 * addOfflineFile 添加离线文件
 * delOfflineFile 删除离线文件
 */
namespace DB_PROXY {

void hasOfflineFile(CImPdu* pPdu, uint32_t conn_uuid);
void addOfflineFile(CImPdu* pPdu, uint32_t conn_uuid);
void delOfflineFile(CImPdu* pPdu, uint32_t conn_uuid);

};

#endif /*defined(__FILEACTION_H__) */

/* db_proxy_server - business - FileAction.cpp */
#include "FileAction.h"
#include "FileModel.h"
#include "IM.File.pb.h"
#include "../ProxyConn.h"

namespace DB_PROXY {

/* 获取离线文件 */
void hasOfflineFile(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::File::IMFileHasOfflineReq msg;
  IM::File::IMFileHasOfflineRsp msgResp;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    CImPdu* pPduRes = new CImPdu;

    uint32_t nUserId = msg.user_id();
    CFileModel* pModel = CFileModel::getInstance();
    list<IM::BaseDefine::OfflineFileInfo> lsOffline;
    pModel->getOfflineFile(nUserId, lsOffline);
    msgResp.set_user_id(nUserId);
    for (list<IM::BaseDefine::OfflineFileInfo>::iterator it=lsOffline.begin(); it != lsOffline.end(); ++it)
    {
      IM::BaseDefine::OfflineFileInfo* pInfo = msgResp.add_offline_file_list();
      //*pInfo = *it;
      pInfo->set_from_user_id(it->from_user_id());
      pInfo->set_task_id(it->task_id());
      pInfo->set_file_name(it->file_name());
      pInfo->set_file_size(it->file_size());
    }

    log("userId=%u, count=%u", nUserId, msgResp.offline_file_list_size());

    msgResp.set_attach_data(msg.attach_data());
    pPduRes->SetPBMsg(&msgResp);
    pPduRes->SetSeqNum(pPdu->GetSeqNum());
    pPduRes->SetServiceId(IM::BaseDefine::SID_FILE);
    pPduRes->SetCommandId(IM::BaseDefine::CID_FILE_HAS_OFFLINE_RES);
    CProxyConn::AddResponsePdu(conn_uuid, pPduRes);
  }
  else
  {
    log("parse pb failed");
  }
}

/* 添加离线文件 */
void addOfflineFile(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::File::IMFileAddOfflineReq msg;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    uint32_t nUserId = msg.from_user_id();
    uint32_t nToId = msg.to_user_id();
    string strTaskId = msg.task_id();
    string strFileName = msg.file_name();
    uint32_t nFileSize = msg.file_size();
    CFileModel* pModel = CFileModel::getInstance();
    pModel->addOfflineFile(nUserId, nToId, strTaskId, strFileName, nFileSize);
    log("fromId=%u, toId=%u, taskId=%s, fileName=%s, fileSize=%u", nUserId, nToId, strTaskId.c_str(), strFileName.c_str(), nFileSize);
  }
}

/* 删除离线文件 */
void delOfflineFile(CImPdu* pPdu, uint32_t conn_uuid)
{
  IM::File::IMFileDelOfflineReq msg;
  if(msg.ParseFromArray(pPdu->GetBodyData(), pPdu->GetBodyLength()))
  {
    uint32_t nUserId = msg.from_user_id();
    uint32_t nToId = msg.to_user_id();
    string strTaskId = msg.task_id();
    CFileModel* pModel = CFileModel::getInstance();
    pModel->delOfflineFile(nUserId, nToId, strTaskId);
    log("fromId=%u, toId=%u, taskId=%s", nUserId, nToId, strTaskId.c_str());
  }
}

};

